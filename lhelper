#!/usr/bin/env bash

LHELPER_COMMAND_NAME="$(basename "$0")"

if [ "$#" -lt 1 ]; then
    echo "Usage: $LHELPER_COMMAND_NAME <command> [<other options>]"
    exit 1
fi

LHELPER_BIN_DIRNAME="$(dirname "$0")"
LHELPER_PREFIX="${LHELPER_BIN_DIRNAME%/bin}"

export LHELPER_WORKING_DIR="$LHELPER_PREFIX/var/lib/lhelper"
export LHELPER_DIR="$LHELPER_PREFIX/share/lhelper"

# The variable below is used by the command lh-path-replace. It is
# needed because in MSYS sometimes unix-like absolute path are used
# like /home/user. These kind of path are fed to the native applications
# transformed into the real windows path like C:/msys64/home/user. Using
# the variable LH_MSYSROOT lh-path-replace will recognize the msys root
# windows path, C:/msys64/ and treat it as if it were the unix /.
if hash cygpath 2> /dev/null; then
    export LH_MSYSROOT="$(cygpath -m /)"
fi

source "$LHELPER_DIR/create-env.sh"

if [ ! -d "${LHELPER_DIR}" ]; then
    echo "error: directory \"${LHELPER_DIR}\" not found."
    echo "Lhelper may be not properly installed."
fi

pushd_quiet () { builtin pushd "$@" > /dev/null; }
popd_quiet () { builtin popd > /dev/null; }

fs_security_delay () {
    # Sometimes on windows we get an error when running tar:
    # tar: <some-file>: file changed as we read it
    # so we add an artificial delay to try to avoid the problem.
    if [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "mingw"* ]]; then
        if command -v sleep &> /dev/null; then
            sleep 1
        else
            ls &> /dev/null
        fi
    fi
}

check_commands () {
    # The arguments should be a list of commands without any argument or space.
    for command in "$@"; do
        # Using exit code 3 to signal a missing command
        type "$command" > /dev/null 2>&1 || { echo >&2 "error: command \"${command}\" is required but it's not available"; return 1; }
    done
}

# https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
# https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#ARM-Options

# https://en.wikipedia.org/wiki/List_of_Intel_CPU_microarchitectures#x86_microarchitectures
# https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels
# https://en.wikipedia.org/wiki/X86#Chronology

# Clang available march: llc -march=x86-64 -mattr=help
# gcc -march=native -Q --help=target

# We do not cover all the OpenBLAS targets for x86/x86-64
# IMPORTANT: for each "architecture" the first line should be the more basic
#            CPU_TARGET supported. It will be chosen as a default if CPU_TARGET is
#            not given.
# meaning: "architecture", "CPU target's name", ""gcc/clang arch name", "additional flags"
known_cpu_spec=(
    "x86    i586        i586             -m32"
    "x86    i686        i686             -m32"
    "x86    pentium2    pentium2         -m32"
    "x86    pentium3    pentium3         -m32,-mfpmath=sse,-msse"
    "x86    pentium4    pentium4         -m32,-mfpmath=sse,-msse2"
    "x86    prescott    prescott         -m32,-mfpmath=sse,-msse2"
    "x86    nehalem     nehalem          -m32,-mfpmath=sse,-msse2"
    "x86    haswell     haswell          -m32,-mfpmath=sse,-msse2"
    "x86-64 x86-64      x86-64        "
    "x86-64 core2       core2         "
    "x86-64 athlon      athlon        "
    "x86-64 opteron     opteron       "
    "x86-64 barcelona   barcelona     "
    "x86-64 bobcat      btver1        " # Bobcat, 1st gen
    "x86-64 jaguar      btver2        " # Bobcat, 2nd gen
    "x86-64 bulldozer   bdver1        " # Bulldozer, 1st gen
    "x86-64 piledriver  bdver2        "
    "x86-64 steamroller bdver3        "
    "x86-64 excavator   bdver4        "
    "x86-64 zen         znver1        "
    "x86-64 x86-64-v2   x86-64-v2     "
    "x86-64 nehalem     nehalem       "
    "x86-64 westmere    westmere       "
    "x86-64 sandybridge sandybridge   "
    "x86-64 x86-64-v3   x86-64-v3     "
    "x86-64 haswell     haswell       "
    "x86-64 broadwell   broadwell     "
    "x86-64 skylake     skylake       "
    "x86-64 cooperlake  cooperlake    "
    "x86-64 atom        bonnell       "
    "x86-64 x86-64-v4   x86-64-v4     "
    "x86-64 skylakex    skylake-avx512"
    "arm    armv6       armv6         "
    "arm    armv6+fp    armv6+fp      "
    "arm    armv7       armv7         "
    "arm    armv7a      armv7-a       "
    "arm    armv7a+fp   armv7-a+fp    "
    "arm    cortexa15   armv7-a+fp     -mtune=cortex-a15"
    "arm    cortexa9    armv7-a+fp     -mtune=cortex-a9"
    "arm64  armv8       armv8-a       "
    "arm64  cortexa53   armv8-a        -mtune=cortex-a53"
    "arm64  cortexa57   armv8-a        -mtune=cortex-a57"
    "arm64  cortexa72   armv8-a        -mtune=cortex-a72"
    "arm64  cortexa73   armv8-a       "
)

find_os_release () {
    local uname_out
    uname_out="$(uname -s)"
    case "${uname_out}" in
        Linux*)
            if [ -f /etc/os-release ]; then
                (source /etc/os-release; echo "$ID-$VERSION_ID")
            elif [ -f /etc/redhat-release ]; then
                rh_line=$(cat /etc/redhat-release)
                rh_regex="Red Hat .* release ([^ ]+)"
                if [[ $rh_line =~ $rh_regex ]]; then
                    echo "rhel-${BASH_REMATCH[1]}"
                else
                    echo "rhel-unknown"
                fi
            elif hash lsb_release 2> /dev/null; then
                dist="$(lsb_release -i)"
                release="$(lsb_release -r)"
                echo "${dist#*:$'\t'}-${release#*:$'\t'}"
            else
                echo "linux-unknown"
            fi
            ;;
        *)
            # On MSYS2 the output is MINGW32_NT-10.0-17763
            if [[ $uname_out =~ ([^\-]+-[^\-]+) ]]; then
                echo "${BASH_REMATCH[1]}"
            else
                echo "${uname_out}"
            fi
    esac
}

prepare_temp_dir () {
    local temp_dir="$1/tmp"
    rm -fr "$temp_dir"
    mkdir "$temp_dir"
}

# Relocate prefix path references for all files in a library install's
# directory.
library_dir_reloc () {
    local archive_dir="$1"
    local old_prefix="$2"
    local new_prefix="$3"
    find "$archive_dir" -type f -exec lh-path-replace '{}' "$old_prefix" "$new_prefix" \;
}

# Extract library archive and relocate prefix path references.
extract_archive_reloc () {
    prepare_temp_dir "$LHELPER_WORKING_DIR"
    local tar_package_filename="$1"
    local old_prefix="$2"
    local new_prefix="$3"
    local _install_prefix="$4"
    local filename_list="$5"
    local package_temp_dir="$LHELPER_WORKING_DIR/tmp"
    tar -C "$package_temp_dir" -xf "$LHELPER_WORKING_DIR/packages/${tar_package_filename}"
    library_dir_reloc "$package_temp_dir" "$old_prefix" "$new_prefix"
    # Getting list of package's files
    pushd_quiet "$package_temp_dir"
    find . > "$filename_list"
    popd_quiet
    # Copy files in the destination directory
    cp -a "$package_temp_dir/." "$_install_prefix"
}

set_prefix_variables () {
    local prefix_dir="$1"
    INSTALL_PREFIX="$prefix_dir"
    if [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "mingw"* ]]; then
        WIN_INSTALL_PREFIX="${INSTALL_PREFIX/#\/c\//c:\/}"
    else
        WIN_INSTALL_PREFIX="${INSTALL_PREFIX}"
    fi
    export INSTALL_PREFIX WIN_INSTALL_PREFIX
}

latest_package_version () {
    local package="$1"
    cat "$LHELPER_DIR/recipes/index" | while read index_package version
    do
        if [[ "$index_package" == "$package" ]]; then
            echo "$version"
            return 0
        fi
    done
    return 1
}

join_by () { local IFS="$1"; shift; echo "$*"; }

# Write a package line in the form "<package-name> [options] [version]" into
# a register file, a line for each package. If the package is already
# in the "register" file the line is updated otherwise it is added at the
# end.
package_file_add () {
    local package_filename="$1" package_name="$2" package_line="${*:2}" found
    local packages_content=() line
    while IFS= read -r line; do
        if [[ "${line%% *}" == "$package_name" ]]; then
            line="$package_line"
            found=yes
        fi
        packages_content+=("$line")
    done < "$package_filename"
    if [ -z ${found+x} ]; then
        packages_content+=("$package_line")
    fi
    true > "$package_filename"
    for line in "${packages_content[@]}"; do
        echo "$line" >> "$package_filename"
    done
}

package_file_remove () {
    local package_filename="$1" package_name="$2"
    local packages_content=() line
    while IFS= read -r line; do
        if [[ "${line%% *}" != "$package_name" ]]; then
            packages_content+=("$line")
        fi
    done < "$package_filename"
    true > "$package_filename"
    for line in "${packages_content[@]}"; do
        echo "$line" >> "$package_filename"
    done
}

package_file_query () {
    local package_filename="$1" package_name="$2"
    local line
    while IFS= read -r line; do
        if [[ "${line%% *}" == "$package_name" ]]; then
            echo "$line"
            return 0
        fi
    done < "$package_filename"
}

register_package () {
    local env_dir="$LHELPER_ENV_PREFIX"
    local provide_line
    package_file_add "$env_dir/bin/lhelper-packages" "$@"
    if [ -f "$LHELPER_ENV_PREFIX/logs/$package-provides" ]; then
        while IFS= read -r provide_line; do
            echo "$provide_line : $*" >> "$env_dir/bin/lhelper-packages"
        done < "$env_dir/logs/$package-provides"
    fi
}

unregister_package () {
    local env_dir="$LHELPER_ENV_PREFIX"
    package_file_remove "$env_dir/bin/lhelper-packages" "$@"
    local un_provided=() un_package
    while IFS= read -r un_package; do
        if [[ "$un_package" == *" : "* ]]; then
            local pprov="${un_package% : *}"
            local pimpl="${un_package#* : }"
            if [[ ${pimpl%% *} == $1 ]]; then
                un_provided+=("${pprov%% *}")
            fi
        fi
    done < "$env_dir/bin/lhelper-packages"
    for un_package in "${un_provided[@]}"; do
        package_file_remove "$env_dir/bin/lhelper-packages" "$un_package"
    done
}

query_package () {
    local env_dir="$LHELPER_ENV_PREFIX"
    local use_link=no
    if [[ "$1" == -link ]]; then
        use_link=yes
        shift
    fi
    local query_line="$(package_file_query "$env_dir/bin/lhelper-packages" "$@")"

    # returns error is line is empty: package not found
    if [[ -z "${query_line// }" ]]; then return 1; fi

    if [[ "$query_line" == *" : "* ]]; then
        if [ $use_link == yes ]; then
            echo "${query_line#* : }"
        else
            echo "${query_line% : *}"
        fi
    else
        echo "$query_line"
    fi
}

package_is_installed () {
    local prefix="$1" package="$2"
    test -f "$prefix/packages/$package.list"
}

remove_package () {
    local prefix="$1" package="$2"
    local filename_list="$prefix/packages/$package.list"
    pushd_quiet "$prefix"
    while IFS= read -r line; do
        if [ -f "$line" ]; then
            # remove the fild installed from package
            rm "$line"
        fi
    done < "$filename_list"
    # Removing empty directories
    find "." -empty -type d -delete
    popd_quiet
    rm "$filename_list"
}

find_recipe_filename () {
    local recipe_dir="$1" package="$2" version="$3"
    local filename recipe_filename
    for filename in "${recipe_dir}/"*; do
        if [[ $filename == *"/${package}_${version}" || $filename == *"/${package}_${version}+"* ]]; then
            recipe_filename="$filename"
        fi
    done
    echo "${recipe_filename#$recipe_dir/}"
}

fix_pkgconfig_install () {
    local found_pkgconfig
    if [[ "${LHELPER_LIBDIR}" != "lib" && -d "${INSTALL_PREFIX}/lib/pkgconfig" ]]; then
        found_pkgconfig="lib/pkgconfig"
    fi
    if [[ "${LHELPER_LIBDIR}" != "lib" && -d "${INSTALL_PREFIX}/share/pkgconfig" ]]; then
        found_pkgconfig="share/pkgconfig"
    fi
    if [ -n "${found_pkgconfig}" ]; then
        local pkgconfig_libdir="$(dirname "${INSTALL_PREFIX}/${found_pkgconfig}")"
        echo "Moving pkgconfig directory from \"$(dirname ${found_pkgconfig})\" to \"${LHELPER_LIBDIR}\""
        mkdir -p "${INSTALL_PREFIX}/${LHELPER_LIBDIR}/pkgconfig"
        mv "${INSTALL_PREFIX}/${found_pkgconfig}" "${INSTALL_PREFIX}/${LHELPER_LIBDIR}"
        # Deleting empty directories in ${pkgconfig_libdir}
        find "$pkgconfig_libdir" -empty -type d -delete
    fi
}

# FIXME: add methods to detect CMake libraries and other system libraries
# that may not have a pkg-config or cmake configuration.
system_library_version () {
    if pkg-config --exists "$1" &> /dev/null; then
        pkg-config --modversion "$1"
    elif command -v "$1-config" &> /dev/null; then
        "$1-config" --version
    else
        return 1
    fi
}

# From: https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

testvercomp () {
    vercomp $1 $2
    case $? in
    0)
        if [[ $3 == *"=" ]]; then
            return 0
        fi
        ;;
    1)
        if [[ $3 == ">"* ]]; then
            return 0
        fi
        ;;
    2)
        if [[ $3 == "<"* ]]; then
            return 0
        fi
        ;;
    esac
    return 1
}

# Check that "$1" is a subset of "$2". Each argument is a space-separated
# list of options.
test_options () {
    local e
    for e in $1; do
        if [[ " $2 " != *" $e "* ]]; then
            return 1
        fi
    done
}

# Test if a package entry, second argument, for example "sdl2 -threads -opengl >=2.16.0",
# matches a package spec, first argument, for example "sdl2 -opengl 2.14.0"
#
# The package spec should give a version with a comparison sign >, >=, < or <=.
test_package_spec () {
    local line_spec="$1"
    local line_entry="$2"
    local skip_options="$3"

    IFS=' ' read -ra spec_a <<< "$line_spec"
    local spec_name="${spec_a[0]}"
    local spec_options=()
    local spec_version
    local spec_comp
    for a in "${spec_a[@]:1}"; do
        case "$a" in
        -*)
            spec_options+=("$a")
            ;;
        '>='* | '<='*)
            spec_comp="${a:0:2}"
            spec_version="${a:2}"
            ;;
        '>'* | '<'* | '='*)
            spec_comp="${a:0:1}"
            spec_version="${a:1}"
            ;;
        *)
            # return 100 means abnormal error happended
            return 100
        esac
    done
    # spec_version may be unset

    IFS=' ' read -ra entry_a <<< "$line_entry"
    local entry_options=()
    local entry_version
    for a in "${entry_a[@]:1}"; do
        case "$a" in
        -*)
            entry_options+=("$a")
            ;;
        *)
            entry_version="$a"
        esac
    done
    # entry_version must be set

    if [ "$spec_name" != "${entry_a[0]}" ]; then
        return 1
    fi

    # checks that all the spec options are included in the entry options
    if [ "${skip_options}" != --skip ] && ! test_options "${spec_options[*]}" "${entry_options[*]}"; then
        # return 2 means options do not match
        return 2
    fi

    if [ ! -z ${spec_version+x} ] && [ ! testvercomp "$entry_version" "$spec_version" "$spec_comp" ]; then
        # return 3 means version do not match
        return 3
    fi
}

lib_install_msg () {
    if [ "$lib_install_mode" == verbose ]; then
        echo "$@"
    fi
}

# fill the _missing array variable
check_dependencies () {
    local cd_package cd_dependency cd_package_found
    _missing=()
    if [ ! -f "$LHELPER_ENV_PREFIX/logs/$package-dependencies" ]; then return 0; fi
    while IFS= read -r cd_dependency; do
        if [[ "$cd_dependency" == "?"* ]]; then
            # skip packages marked with '?' as they are not required.
            continue
        fi
        cd_package=${cd_dependency/ */}
        unset cd_package_found
        if query_package $cd_package &> /dev/null; then
            cd_package_found="$(query_package $cd_package)"
        fi
        if [ ! -z ${cd_package_found+x} ]; then
            test_package_spec "$cd_dependency" "$cd_package_found"
            case $? in
            1)
                echo "Error: internal error, package name mismatch."
                exit 1
                ;;
            2)
                echo "Error: options for installed package $cd_package does not match."
                exit 1
                ;;
            3)
                echo "Error: incompatible version for installed package $cd_package."
                exit 1
                ;;
            100)
                echo "Error: Invalid package spec: \"$cd_dependency\""
                exit 1
                ;;
            # otherwise package is already installed: do nothing
            esac
        elif system_library_version "$cd_package" &> /dev/null; then
            cd_package_found="$name $(system_library_version "$cd_package")"
            if ! test_package_spec "$cd_dependency" "$cd_package_found" --skip; then
                echo "Error: incompatible version for system library $name."
                exit 1
            fi
            # Using system library
        else
            _missing+=("$cd_dependency")
        fi
    done < "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
}

contains_element () {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

compute_package_list () {
    if [ ! -f "$LHELPER_ENV_PREFIX/logs/$package-dependencies" ]; then
        return 0
    fi
    local cp_dependency cp_name cp_version cp_entry
    while IFS= read -r cp_dependency; do
        cp_name=${cp_dependency/ */}
        cp_name=${cp_name#\?}
        if query_package "$cp_name" &> /dev/null; then
            cp_entry="$(query_package -link $cp_name)"
            if ! contains_element "$cp_entry" "${_pack_usage[@]}"; then
                _pack_usage+=("$cp_entry")
            fi
        elif system_library_version "$cp_name" &> /dev/null; then
            cp_version="$(system_library_version "$cp_name")"
            _pack_usage+=("${cp_name}[system] ${cp_version}")
        else
            _pack_usage+=("${cp_name}[not-found]")
        fi
    done < "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
}

get_compiler_version () {
    local cc="$1"
    local ver="$($cc --version | head -n 1)"
    if [[ "$ver" =~ gcc.*\((.*)\)\ +([0-9]+)\.[0-9]+.* ]]; then
        echo "gcc (${BASH_REMATCH[1]}) ${BASH_REMATCH[2]}"
    elif [[ "$ver" =~ g\+\+.*\((.*)\)\ +([0-9]+)\.[0-9]+.* ]]; then
        echo "g++ (${BASH_REMATCH[1]}) ${BASH_REMATCH[2]}"
    elif [[ "$ver" =~ clang\ +version\ +([0-9]+)\.[0-9]+.* ]]; then
        echo "clang ${BASH_REMATCH[1]}"
    else
        echo "$ver"
    fi
}

cat_digest () {
    cat << EOF
CC="$CC_BARE"
CXX="$CXX_BARE"
CFLAGS="$CFLAGS"
CXXFLAGS="$CXXFLAGS"
LDFLAGS="$LDFLAGS"
BUILD_TYPE="$BUILD_TYPE"
MACHTYPE="$MACHTYPE"
CPU_TYPE="$CPU_TYPE"
CPU_TARGET="$CPU_TARGET"
CC_VERSION="$(get_compiler_version "$CC_BARE")"
CXX_VERSION="$(get_compiler_version "$CXX_BARE")"
OS_VERSION="$(find_os_release)"
EOF
    echo '# dependencies'
    echo 'cat << END_OF_DEPENDENCIES'
    cat "$LHELPER_ENV_PREFIX/logs/$package-usage"
    echo 'END_OF_DEPENDENCIES'
}


build_env_digest () {
    local _pack_usage=()
    compute_package_list
    source "$LHELPER_ENV_PREFIX/bin/lhelper-config"

    true > "$LHELPER_ENV_PREFIX/logs/$package-usage"
    local line
    for line in "${_pack_usage[@]}"; do
        echo "$line" >> "$LHELPER_ENV_PREFIX/logs/$package-usage"
    done
    unset _pack_usage

    local digest_a=($(cat_digest | md5sum))
    local digest="${digest_a[0]}"

    if [ ! -f "$LHELPER_WORKING_DIR/digests/$digest" ]; then
        cat_digest > "$LHELPER_WORKING_DIR/digests/$digest"
    fi
    echo "$digest"
}


# The first argument, $run_mode, should be either "dependencies", "run" or "log"
library_install () {
    local run_mode="$1"
    shift

    local local_recipe
    local rebuild
    while [[ "$1" == -* ]]; do
        case "$1" in
        --local)
            local_recipe=true
            ;;
        --rebuild)
            rebuild=true
            ;;
        *)
            echo "unknown install option: $1"
            exit 1
        esac
        shift
    done
    local package="$1"
    shift

    local version
    local options_a=()
    for opt in "${@:1}"; do
        case $opt in
            -pic)
                if [[ ! $MACHTYPE =~ (mingw|msys|cygwin) ]]; then
                    options_a+=("$opt")
                fi
                shift
                ;;
            -*)
                options_a+=("$opt")
                shift
                ;;
            *)
                if [ -n "$version" ]; then
                    echo "Unrecognized package argument \"$1\""
                    exit 1
                fi
                version="$1"
                shift
                ;;
        esac
    done

    options_a=($(lh-sort "${options_a[*]}"))

    local options_tag=""
    if [[ ${#options_a[@]} -ne 0 ]]; then
        options_tag=$(join_by '' "${options_a[@]}")
        options_tag="${options_tag/#-/_}"
    fi

    if [[ "$local_recipe" == "true" && -z ${version+set} ]]; then
        echo "error: version is required for local recipes"
        exit 1
    fi
    if [ -z "${version+set}" ]; then
        version="$(latest_package_version "$package")"
        if [ -z "$version" ]; then
            echo "error: cannot find package \"${package}\""
            exit 1
        fi
    fi
    local recipe_dir
    if [ -z ${local_recipe+set} ]; then
        recipe_dir="$LHELPER_DIR/recipes"
    else
        recipe_dir=.
    fi
    local recipe_filename="$(find_recipe_filename "${recipe_dir}" "$package" "$version")"
    if [ -z "${recipe_filename}" ]; then
        echo "error: no recipe found for \"${package}\" version ${version}."
        exit 1
    fi
    local recipe_version="${recipe_filename#${package}_}"

    if [ $run_mode == run ]; then
        if [[ ${#options_a[@]} -eq 0 ]]; then
            lib_install_msg "Using recipe version ${recipe_version}"
        else
            lib_install_msg "Using recipe version ${recipe_version} with options: ${options_a[*]}"
        fi

        if package_is_installed "$LHELPER_ENV_PREFIX" "$package"; then
            remove_package "$LHELPER_ENV_PREFIX" "$package"
            lib_install_msg "Removed previously installed package \"$package\""
        fi
    fi

    LHELPER_TEMP_ROOT="$LHELPER_WORKING_DIR/tmp"
    set_prefix_variables "$LHELPER_TEMP_ROOT"

    source "$LHELPER_ENV_PREFIX/bin/lhelper-config"

    export package version
    export _lh_recipe_run=$run_mode
    local log_dirname="${LHELPER_ENV_PREFIX}/logs"
    local digest
    if [ $run_mode == dependencies ]; then
        # Running recipe to get dependencies
        true > "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
        true > "$LHELPER_ENV_PREFIX/logs/$package-provides"
        BASH_ENV="$LHELPER_DIR/build-helper.sh" bash -e "${recipe_dir}/${recipe_filename}" "${options_a[@]}" 2> "$log_dirname/deps-$package-stderr.log" 1> "$log_dirname/deps-$package-stdout.log"
        check_dependencies
        unset _lh_recipe_run
        return 0
    elif [ $run_mode == log ]; then
        digest=$(build_env_digest)
        register_package "$package" "$recipe_version" "${options_a[@]}" "$digest"
        return 0
    else
        digest=$(build_env_digest)
    fi

    local pu_line
    local pu_list=()
    while IFS= read -r pu_line; do
        pu_list+=("$pu_line")
    done < "$LHELPER_ENV_PREFIX/logs/$package-usage"
    rm "$LHELPER_ENV_PREFIX/logs/$package-usage"
    if [ ! -z ${show_dependencies+x} ]; then
        if [[ ${#pu_list[@]} -gt 0 ]]; then
            lib_install_msg "The package dependencies are:"; echo
            for pu_line in "${pu_list[@]}"; do
                lib_install_msg "* $pu_line"
            done
            lib_install_msg
        else
            lib_install_msg "The package has no dependencies."
        fi
    fi

    local tar_package_filename="${package}${options_tag}_${recipe_version}_${digest}.tar.gz"
    if [[ -z ${rebuild+set} && -z ${local_recipe+set} && "$version" != "git-"* && -f "$LHELPER_WORKING_DIR/packages/${tar_package_filename}" ]]; then
        lib_install_msg "Found an existing package"
    else
        prepare_temp_dir "$LHELPER_WORKING_DIR"
        lib_install_msg "Building library..."
        # Execute the recipe
        BASH_ENV="$LHELPER_DIR/build-helper.sh" bash -e "${recipe_dir}/${recipe_filename}" "${options_a[@]}" 2> "$log_dirname/$package-stderr.log" 1> "$log_dirname/$package-stdout.log"
        case $? in
        0) ;;
        3)
            echo "Some of the required commands for $package is missing:"; echo
            cat "$log_dirname/$package-stderr.log"
            exit 1
            ;;
        4)
            echo "error: package install was interruped."
            exit 1
            ;;
        5)
            echo "Error downloading the source code for $package:"; echo
            cat "$log_dirname/$package-stderr.log"
            exit 1
            ;;
        6)
            echo "Error while building the source code for $package:"; echo
            cat "$log_dirname/$package-stderr.log"
            exit 1
            ;;
        *)
            echo "error: building library \"$package\""
            echo "    You may inspect the log files:"
            echo
            echo "    $package-stdout.log"
            echo "    $package-stderr.log"
            echo
            echo "    located in the directory $log_dirname"
            exit 1
            ;;
        esac
        fix_pkgconfig_install
        lib_install_msg "done"

        library_dir_reloc "$LHELPER_TEMP_ROOT" "$WIN_INSTALL_PREFIX" "__LHELPER_PREFIX__"

        fs_security_delay
        tar -C "$LHELPER_TEMP_ROOT" -czf "${tar_package_filename}" .
        mv "${tar_package_filename}" "$LHELPER_WORKING_DIR/packages"
        echo "Saved package for \"$package\""
    fi
    unset _lh_recipe_run
    set_prefix_variables "$LHELPER_ENV_PREFIX"
    local filename_list="$LHELPER_ENV_PREFIX/packages/${package}.list"
    extract_archive_reloc "${tar_package_filename}" '__LHELPER_PREFIX__' "$WIN_INSTALL_PREFIX" "$INSTALL_PREFIX" "$filename_list"
    register_package "$package" "$recipe_version" "${options_a[@]}" "$digest"
    lib_install_msg "Package \"$package\" successfully installed"
}

library_remove () {
    local package="$1"
    if ! package_is_installed "$LHELPER_ENV_PREFIX" "$package"; then
        echo "package \"$package\" not installed"
        exit 1
    fi
    remove_package "$LHELPER_ENV_PREFIX" "$package"
    unregister_package "$package"
    echo "Package \"$package\" successfully removed."
}

print_installed_packages () {
    local packages_file="${LHELPER_ENV_PREFIX}/bin/lhelper-packages"
    if [ -s $packages_file ]; then
        echo "Installed packages"
        echo
        while IFS= read -r line; do
            local line_p="${line% *}" digest="${line##* }"
            if [[ "$line_p" == *" : "* ]]; then
                echo "* ${line_p% : *} [provided by ${line_p#* : } (${digest::8})]"
            else
                echo "* $line_p (${digest::8})"
            fi
        done < $packages_file
        echo
    else
        echo "No package installed."
    fi
}

start_subshell () {
    print_installed_packages
    exec bash --init-file "$LHELPER_DIR/lhelper-bash-init"
}

# Take the environment name and its install prefix as arguments.
print_create_env_message () {
    echo "Environment \"$1\" created [$2]"
}

print_package_files () {
    local package="$1"
    cat "$LHELPER_ENV_PREFIX/packages/${package}.list"
}

check_env_active_or_exit () {
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        echo "No environment activated"
        echo "To list the packages an environment should be activated"
        exit 1
    fi
}

library_check_and_install () {
    local mode=$1
    shift

    local _missing=()
    # get dependencies
    library_install dependencies "$@"
    if [[ ${#_missing[@]} -ne 0 ]]; then
        lib_install_msg "Found missing packages:"; echo
        for line in "${_missing[@]}"; do
            lib_install_msg "- $line"
        done
        lib_install_msg; lib_install_msg "The package $1 cannot be installed due to missing dependencies."
        exit 1
    fi
    if [ $mode == run ]; then
        lib_install_msg "Installing the requested package: $@"
    fi
    library_install $mode "$@"
}

# Modify a package line so that it can be passed to library_check_and_install
# to install the same package.
# Remove the recipe version number after "+" in the 2nd argument and discard
# the last argument, which is the digest of the package.
package_of_line () {
    join_by " " "$1" "${2%+*}" "${@:3:${#@}-3}"
}

# Update list of packages on the currently activated environment to match the
# temporary environment whose env dir is given as the first argument.
update_installed_packages () {
    local new_env_dir="$1"

    # Below old_list is the list of the currently installed packages while new_list
    # is the list we want to have.
    # We proceed to remove or install packages so that we match the "new_list" of
    # installed packages.
    local old_list=() new_list=() ll
    while IFS= read -r ll; do old_list+=("$ll"); done < "$LHELPER_ENV_PREFIX/bin/lhelper-packages"
    while IFS= read -r ll; do new_list+=("$ll"); done < "$new_env_dir/bin/lhelper-packages"

    fs_security_delay
    # truncate the lhelper-packages file
    true > "$LHELPER_ENV_PREFIX/bin/lhelper-packages"

    local newly_installed_packages=()
    local skip_this newly_installed_package
    local package_line i=0 j=0 n=${#new_list[@]} m=${#old_list[@]} k found
    while [[ $i -lt $n ]]; do
        # in the condition below $j may be out of bounds but that's fine.
        if [[ ${new_list[$i]} == ${old_list[$j]} ]]; then
            # lines match: write the line in lhelper-packages and move on
            echo "${new_list[$i]}" >> "$LHELPER_ENV_PREFIX/bin/lhelper-packages"
            i=$(( $i + 1 ))
            j=$(( $j + 1 ))
        else
            # entries do not match: let's see if the entry in new_list is present
            # is old_list but later
            k=$(( $j + 1 ))
            found=no
            while [[ $k -lt $m ]]; do
                if [[ ${new_list[$i]} == ${old_list[$k]} ]]; then
                    found=yes
                    break
                fi
                k=$(( $k + 1 ))
            done
            if [ $found == yes ]; then
                # the new_list entry is found: remove all the old_list entries up to
                # the one that match the new_list entry
                while [[ $j -lt $k ]]; do
                    skip_this=no
                    for newly_installed_package in "${newly_installed_packages[@]}"; do
                        if [[ ${old_list[$j]%% *} == $newly_installed_package ]]; then
                            skip_this=yes
                            break
                        fi
                    done
                    if [[ $skip_this == no && ${old_list[$j]} != *" : "* ]]; then
                        remove_package "$LHELPER_ENV_PREFIX" ${old_list[$j]}
                    fi
                    j=$(( $j + 1 ))
                done
            else
                # The new_list entry is not found: install it in the new environment.
                # NOTE: it will add one or more new lines in the lhelper-packages file.
                # It will be more than one if the packages "provides" some virtual packages.
                if [[ ${new_list[$i]} != *" : "* ]]; then
                    # Just take the name of the package for the list of newly installed packages.
                    newly_installed_packages+=("${new_list[$i]%% *}")
                    library_check_and_install run $(package_of_line ${new_list[$i]})
                fi
                i=$(( $i + 1 ))
            fi
        fi
    done
    # Remove any remaining package not present in the new list
    while [[ $j -lt $m ]]; do
        # Check if the package was just installed before removing it.
        # The package may be required with different options.
        # If this is the case it was previously removed and installed above in this function using
        # library_check_and_install with the new options so we don't want to remove it again here
        # because we would remove the newly installed package.
        skip_this=no
        for newly_installed_package in "${newly_installed_packages[@]}"; do
            if [[ ${old_list[$j]%% *} == $newly_installed_package ]]; then
                skip_this=yes
                break
            fi
        done
        if [[ $skip_this == no && ${old_list[$j]} != *" : "* ]]; then
            remove_package "$LHELPER_ENV_PREFIX" ${old_list[$j]}
        fi
        j=$(( $j + 1 ))
    done
}

# Create and activate a temporary environment in the given directory
# and pseudo-installs the packages from the array variable "packages"
do_temporary_env () {
    local prev_mode="$lib_install_mode"
    lib_install_mode=quiet
    local env_dir="$1"
    local env_source="$env_dir/.source"
    rm -fr "$env_dir"
    mkdir -p "$env_dir"
    create_env "_tmp" "$env_dir" "$env_source"
    # run through the packages to log them in the temporary environment
    (
        source "$env_source"
        for package_name in "${packages[@]}"; do
            # Important: variable package_name can contain spaces and it must be used
            # below *without* quotes.
            library_check_and_install log $package_name
        done
    )
    lib_install_mode="$prev_mode"
}

# should be called using a subshell
check_env_root_match () {
    local env_source="$1"
    source "$env_source"
    if [ "$LHELPER_ENV_ROOT" == "$PWD" ]; then echo true; else echo false; fi
}

# Load the environment if the given name only if its config matches.
# It the config matches return 0 or 1 otherwise.
load_matching_env () {
    local env_name="$1" env_workdir="$2" tmp_workdir="$3"
    local env_prefix="$env_workdir/$env_name"
    local env_source="$env_prefix/bin/activate"

    # Temporary environment creation and activation using local variable
    # array "packages"
    do_temporary_env "$tmp_workdir"

    local load_exit_code=1
    if [ -d "$env_workdir/$env_name" ] &&
        lh-cmp "$tmp_workdir/bin/lhelper-config" "$env_workdir/$env_name/bin/lhelper-config"; then
        if [ $(check_env_root_match "$env_source") == true ]; then
            source "$env_source"
            update_installed_packages "$tmp_workdir"
            load_exit_code=0
        fi
    fi
    rm -fr "$tmp_workdir"
    return $load_exit_code
}

# Set CPU_TYPE and CPU_TARGET if any of them is missing.
# using locals cpu_type_guess and cpu_target_guess
guess_missing_cpu_type_target () {
    if [[ -z ${CPU_TYPE+x} ]]; then
        if [[ -z ${CPU_TARGET+x} ]]; then
            # Both CPU_TYPE and CPU_TARGET are unset
            CPU_TYPE="$cpu_type_guess"
            CPU_TARGET="$cpu_target_guess"
            echo "Using CPU_TYPE=$CPU_TYPE and CPU_TARGET=$CPU_TARGET"
        else
            # Case CPU_TARGET is given but not CPU_TYPE
            declare -A cpu_type_set
            local cpu_type_count=1 line cpu_type_i
            for line in "${known_cpu_spec[@]}"; do
                read -a line_a <<< "$line"
                if [[ "${line_a[1]}" == "$CPU_TARGET" ]]; then
                    cpu_type_set[${line_a[0]}]=$cpu_type_count
                    cpu_type_count=$(( $cpu_type_count + 1 ))
                fi
            done
            for cpu_type_i in "${!cpu_type_set[@]}"; do
                if [[ "$cpu_type_i" == "$cpu_type_guess" ]]; then
                    CPU_TYPE="$cpu_type_guess"
                    break
                fi
            done
            if [[ -z ${CPU_TYPE+x} ]]; then
                for cpu_type_i in "${!cpu_type_set[@]}"; do
                    if [[ ${cpu_type_set[$cpu_type_i]} == 1 ]]; then
                        CPU_TYPE="$cpu_type_i"
                        break
                    fi
                done
            fi
            if [[ -z ${CPU_TYPE+x} ]]; then
                echo "error: cannot find CPU_TYPE for $CPU_TARGET"
                exit 1
            fi
            echo "Using CPU_TYPE=$CPU_TYPE"
        fi
    elif [[ -z ${CPU_TARGET+x} ]]; then
        # Case CPU_TYPE is given but not CPU_TARGET
        # Take the first line of known_cpu_spec matching the CPU_TYPE
        for line in "${known_cpu_spec[@]}"; do
            read -a line_a <<< "$line"
            if [[ "${line_a[0]}" == "$CPU_TYPE" ]]; then
                CPU_TARGET="${line_a[1]}"
                echo "Using CPU_TARGET=$CPU_TARGET"
                break
            fi
        done
    fi
}

activate_command () {
    if [[ $# -lt 2 || $2 == "-"* ]]; then
        echo "Usage: $LHELPER_COMMAND_NAME activate <spec-filename> [options]"
        exit 1
    fi
    local command="$1" build_filename="$2"
    local lib_install_mode=verbose edit_file show_dependencies
    shift 2
    local ini_packages=()
    while [ ! -z ${1+x} ]; do
        case "$1" in
        -e | --edit)
            edit_file=yes
            ;;
        --show-dependencies)
            show_dependencies=yes
            ;;
        --packages)
            ini_packages=("${@:2}")
            break
            ;;
        -*)
            echo "error: unknown option $1"
            exit 1
            ;;
        *)
            echo "error: unexpected argument: \"$1\""
            exit 1
            ;;
        esac
        shift
    done

    local build_basename
    if [[ ! -f "$build_filename" && ! $build_filename =~ \.lhelper$ ]]; then
        build_filename="$build_filename.lhelper"
    fi
    build_basename="$(basename "$build_filename")"

    local mach_cpu="${MACHTYPE%%-*}"
    local cpu_type_guess cpu_target_guess cpu_help
    case "$mach_cpu" in
    x86_64)
        cpu_type_guess="x86-64"
        cpu_target_guess="x86-64"
        read -r -d '' cpu_help << END_X86_64_HELP
# Possible values for CPU_TARGET are:
#
# x86-64 core2 athlon opteron barcelona bobcat jaguar bulldozer piledriver steamroller excavator
# zen x86-64-v2 nehalem westmere sandybridge x86-64-v3 haswell broadwell skylake cooperlake atom
# x86-64-v4 skylakex
#
# You may use a generic CPU architecture for CPU_TARGET like:
#
# x86-64       Support MMX SSE SSE2 FXSR
# x86-64-v2    Support SSE3 SSE4_1 SSE4_2 SSSE3
# x86-64-v3    Support AVX AVX2
# x86-64-v4    Support AVX512
#
# For more informations: https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels
END_X86_64_HELP
        ;;
    i586)
        cpu_type_guess="x86"
        cpu_target_guess="i586"
        read -r -d '' cpu_help << END_I586
# For ancient i586 this is the only supported CPU_TARGET.
# It does not support any SIMD extension but has FPU support.
#
# For more information:
#
# https://en.wikipedia.org/wiki/X86#Chronology
# https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
END_I586
        ;;
    i686)
        cpu_type_guess="x86"
        cpu_target_guess="i686"
        read -r -d '' cpu_help << END_I686
# Possible values for CPU_TARGET are:
#
# i686 pentium2 pentium3 pentium4 prescott nehalem haswell
#
# You may use a generic CPU architecture for CPU_TARGET like:
#
# i686         No SIMD extensions
# pentium2     Support MMX FXSR
# pentium3     Support MMX SSE FXSR
# pentium4     Support MMX SSE SSE2 FXSR
#
# For more information:
#
# https://en.wikipedia.org/wiki/X86#Chronology
# https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
END_I686
        ;;
    arm64* | aarch64)
        cpu_type_guess="arm64"
        cpu_target_guess="armv8"
        read -r -d '' cpu_help << END_ARM64
# Possible values for CPU_TARGET are:
#
# armv8 cortexa53 cortexa57 cortexa72 cortexa73
#
# You may use a generic CPU architecture for CPU_TARGET like armv8.
#
# For more information:
#
# https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#ARM-Options
END_ARM64
        ;;
    arm*)
        cpu_type_guess="arm"
        cpu_target_guess="armv6"
        read -r -d '' cpu_help << END_ARM32
# Possible values for CPU_TARGET are:
#
# armv6 armv6+fp armv7 armv7a armv7a+fp cortexa9 cortexa15
#
# You may use a generic CPU architecture for CPU_TARGET like:
#
# armv6        No FPU support
# armv6+fp     Include VFPv2 support
# armv7        No FPU support
# armv7a       No FPU support
# armv7a+fp    Include VFPv3 support
#
# For more information:
#
# https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#ARM-Options
END_ARM32
        ;;
    *)
        cpu_type_guess="unknown"
        cpu_target_guess="unknown"
        cpu_help="# The CPU type is unknown. You may contact the lhelper developers."
        ;;
    esac
    flags_ls=()
    for var_name in CFLAGS CXXFLAGS LDFLAGS; do
        if [ -z ${!var_name+x} ]; then
            flags_ls+=("# $var_name=")
        else
            flags_ls+=("$var_name=\"${!var_name}\"")
        fi
    done
    printf -v flags_txt "%s\n" "${flags_ls[@]}"
    if [[ ( ! -z ${edit_file+x} || $command == create ) && ! -f "$build_filename" ]]; then
        cat << EOF > "$build_filename"
# This is bash script sourced to get some environment variables to configure the
# build toolchain.

# Set the variables CC and CXX to point to the C and C++ compilers to use.
# They may contains options by separating them by spaces and quoting the command.
CC="\${CC:-gcc}"
CXX="\${CXX:-g++}"

# Optional C/C++ and linker flags. Do not include optimization or debug flags,
# they are automatically added based on the variables BUILD_TYPE, CPU_TYPE and CPU_TARGET.
$flags_txt

# CPU architecture type and specific CPU to target. These variables are mandatory.
$cpu_help
#
# If CPU_TYPE and CPU_TARGET are not given they will be chosen based on the system
# currently used. You may give some specific value below to force a build for a specific
# architecture.
#
# CPU_TYPE="$cpu_type_guess"
# CPU_TARGET="$cpu_target_guess"

# Debug can be used to build the libraries including debug information.
# It omitted will defaut to a release build.
BUILD_TYPE="${BUILD_TYPE:-Release}"

# List of libraries to be installed. Can contain options by quoting the a string with
# the libray name and its option followed by spaces.
# For example:
# packages=("freetype2"  "sdl2 -opengl")
packages=($(printf '"%s" ' "${ini_packages[@]}"))
EOF
    fi
    if [[ ! -z ${edit_file+x} ]]; then
        "${EDITOR-vim}" "$build_filename"
    fi
    if [[ $command == activate && ! -f "$build_filename" ]]; then
        echo "error: the file $build_filename does not exist or is not a file"
        exit 1
    fi

    source "$build_filename"
    if [ -z ${BUILD_TYPE+x} ]; then
        BUILD_TYPE=Release
    elif [[ $BUILD_TYPE != "Release" && $BUILD_TYPE != "Debug" ]]; then
        echo "Build type should be either Release or Debug, abort."
        exit 1
    fi

    guess_missing_cpu_type_target

    local build_realpath="$(lh-realpath "$build_filename")"
    local env_rel_workdir=".lhelper/env" tmp_rel_workdir=".lhelper/tmp"
    local env_workdir="$(dirname "$build_realpath")/$env_rel_workdir"
    local tmp_workdir="$(dirname "$build_realpath")/$tmp_rel_workdir"
    if [ ! -d "$env_workdir" ]; then
        mkdir -p "$env_workdir" || {
            echo "error: cannot create local environment directory: $env_workdir"
            exit 1
        }
    fi

    local env_test_name="${build_basename%.lhelper}"
    local start_env_shell=true
    while [ $start_env_shell == true ]; do
        start_env_shell=false
        # Below we need to start a subshell so that when we source the environment
        # "activate" script it doesn't pollute the parent bash process. This is required
        # so that if we restart the environment we restart it with clean environment variables
        (
            if ! load_matching_env "$env_test_name" "$env_workdir" "$tmp_workdir"; then
                # Create a new environment.
                # IMPORTANT: env_prefix below, passed to the function create_env, must be set to the
                # relative environment workdir, not the absolute one.
                rm -fr "$env_rel_workdir/$env_test_name"
                env_prefix="$env_rel_workdir/$env_test_name"
                env_source="$env_prefix/bin/activate"
                create_env "$env_test_name" "$env_prefix" "$env_source" "$build_filename"
                # install packages, activate the environment before
                source "$env_source"
                for package_name in "${packages[@]}"; do
                    # Important: variable package_name can contain spaces and it must be used
                    # below *without* quotes.
                    library_check_and_install run $package_name
                done
            fi
            if [ $command == activate ]; then
                echo "Starting a new shell with the new environment"
                # the function below should exec the new bash so that, when it exits
                # the subshell here within the enclosing brackets will terminate
                start_subshell
            fi
        )
        # We consider an exit status 11 as a request to restart the environment
        # after a change in the build file.
        if [[ $? == 11 && $command == activate ]]; then
            start_env_shell=true
            # Source the new build file
            source "$build_filename"
        fi
    done
}

update_command () {
    local branch_name
    if [ "$2" == recipes ]; then
        pushd_quiet "${LHELPER_DIR}/recipes"
        echo "Updating recipes"
        branch_name="$(git rev-parse --abbrev-ref HEAD)"
        git fetch origin "$branch_name"
        git checkout -q -f "$branch_name"
        git reset --hard "origin/$branch_name"
        popd_quiet
    else
        echo "Usage: $LHELPER_COMMAND_NAME update recipes"
        exit 1
    fi
}

install_command () {
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME install <library-name> [version]"
        exit 1
    fi
    check_env_active_or_exit
    local lib_install_mode=verbose
    library_check_and_install run "${@:2}"
}

# The compiler gcc or clang are checked when installing lhelper.
# tar, gzip, git and curl are essential to fetch and pack or unpack source code and
# compiled packages.
# In theory pkg-config may be required for each package that actually need it but that's
# not very practical.
# Note that the following commands may be needed by specific recipes and should be
# verified from the recipe itself: make, ninja, meson, cmake, grep, cmp, diff.
# Recipes my possibly needs also other programs like python, perl or other.
# We don't check for "ar" but we may. Normally if gcc or clang are available "ar" will
# be available to as well as the linker.
required_commands=(tar gzip git curl pkg-config)
check_commands "${required_commands[@]}" || {
    echo "Make sure the commands: ${required_commands[@]} are available."
    exit 1
}

case $1 in
install)
    install_command "$@"
    ;;
create | activate)
    activate_command "$@"
    ;;
env-source)
    if [ $# -ne 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME env-source <spec-filename>"
        exit 1
    fi
    env_name="${2%.lhelper}"
    env_dir="$LHELPER_ENV_ROOT${LHELPER_ENV_ROOT+/}.lhelper/env"
    if [ -f "$env_name.lhelper" ] && [ -d "$env_dir/$env_name/bin" ]; then
        echo "$env_dir/$env_name/bin/activate"
    else
        echo "error: invalid environment name: $2"
        echo "The spec file \"$env_name.lhelper\" does not exit or the environment"
        echo "is not yet created. You may need to run the \"create\" command."
        exit 1
    fi
    ;;
edit | reload)
    check_env_active_or_exit
    if [ $1 == edit ]; then
        # LHELPER_BUILD_FILENAME must be defined here. It is empty only for
        # temporary environment not directly used by users.
        "${EDITOR-vim}" "$LHELPER_ENV_ROOT/$LHELPER_BUILD_FILENAME"
    fi
    # We send a SIGUSR1 to the parent process, the activated bash shell.
    # The variable PPID is a builtin bash variable for the PID of the parent process.
    kill -s SIGUSR1 $PPID
    ;;
cleanup)
    clean_env_dir="$LHELPER_ENV_ROOT${LHELPER_ENV_ROOT+/}.lhelper/env"
    if [ -d "$clean_env_dir" ]; then
        echo "Cleaning up the environments stored in \"$clean_env_dir\""
        rm -fr "$clean_env_dir"/*
    fi
    ;;
remove)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME remove <library-name>"
        exit 1
    fi
    check_env_active_or_exit
    library_remove "${@:2}"
    ;;
list)
    if [ "$2" == recipes ]; then
        ls -1 "$LHELPER_DIR/recipes"
    elif [ "$2" == packages ]; then
        check_env_active_or_exit
        print_installed_packages
    elif [[ "$2" == files && -n ${3+x} ]]; then
        check_env_active_or_exit
        print_package_files "$3"
    else
        echo "Usage: $LHELPER_COMMAND_NAME list (files|environments|recipes) [package]"
        exit 1
    fi
    ;;
dir)
    check_env_active_or_exit
    echo "${LHELPER_ENV_PREFIX}"
    ;;
update)
    update_command "$@"
    ;;
*)
    echo "error: unknown command $1"
    exit 1
    ;;
esac

#!/usr/bin/env bash

LHELPER_COMMAND_NAME="$(basename "$0")"

if [ "$#" -lt 1 ]; then
    echo "Usage: $LHELPER_COMMAND_NAME <command> [<other options>]"
    exit 1
fi

LHELPER_BIN_DIRNAME="$(dirname "$0")"
LHELPER_PREFIX="${LHELPER_BIN_DIRNAME%/bin}"

export LHELPER_WORKING_DIR="$LHELPER_PREFIX/var/lib/lhelper"
export LHELPER_DIR="$LHELPER_PREFIX/share/lhelper"

if [ ! -d "${LHELPER_DIR}" ]; then
    echo "error: directory \"${LHELPER_DIR}\" not found."
    echo "Lhelper may be not properly installed."
fi

pushd_quiet () { builtin pushd "$@" > /dev/null; }
popd_quiet () { builtin popd > /dev/null; }

find_os_release () {
    local uname_out
    uname_out="$(uname -s)"
    case "${uname_out}" in
        Linux*)
            if [ -f /etc/os-release ]; then
                (source /etc/os-release; echo "$ID-$VERSION_ID")
            elif [ -f /etc/redhat-release ]; then
                rh_line=$(cat /etc/redhat-release)
                rh_regex="Red Hat .* release ([^ ]+)"
                if [[ $rh_line =~ $rh_regex ]]; then
                    echo "rhel-${BASH_REMATCH[1]}"
                else
                    echo "rhel-unknown"
                fi
            elif hash lsb_release 2> /dev/null; then
                dist="$(lsb_release -i)"
                release="$(lsb_release -r)"
                echo "${dist#*:$'\t'}-${release#*:$'\t'}"
            else
                echo "linux-unknown"
            fi
            ;;
        *)
            # On MSYS2 the output is MINGW32_NT-10.0-17763
            if [[ $uname_out =~ ([^\-]+-[^\-]+) ]]; then
                echo "${BASH_REMATCH[1]}"
            else
                echo "${uname_out}"
            fi
    esac
}

prepare_temp_dir () {
    local temp_dir="$1/tmp"
    rm -fr "$temp_dir"
    mkdir "$temp_dir"
}

# Relocate prefix path references for all files in a library install's
# directory.
library_dir_reloc () {
    local archive_dir="$1"
    local old_prefix="$2"
    local new_prefix="$3"
    find "$archive_dir" '(' -name '*.la' -or -name '*.pc' -or -name '*-config' ')' -exec lh-path-replace '{}' "$old_prefix" "$new_prefix" \;
}

# Extract library archive and relocate prefix path references.
extract_archive_reloc () {
    prepare_temp_dir "$LHELPER_WORKING_DIR"
    local tar_package_filename="$1"
    local old_prefix="$2"
    local new_prefix="$3"
    local _install_prefix="$4"
    local filename_list="$5"
    local package_temp_dir="$LHELPER_WORKING_DIR/tmp"
    tar -C "$package_temp_dir" -xf "$LHELPER_WORKING_DIR/packages/${tar_package_filename}"
    library_dir_reloc "$package_temp_dir" "$old_prefix" "$new_prefix"
    # Getting list of package's files
    pushd_quiet "$package_temp_dir"
    find . > "$filename_list"
    popd_quiet
    # Copy files in the destination directory
    cp -a "$package_temp_dir/." "$_install_prefix"
}

set_prefix_variables () {
    local prefix_dir="$1"
    INSTALL_PREFIX="$prefix_dir"
    if [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "mingw"* ]]; then
        WIN_INSTALL_PREFIX="${INSTALL_PREFIX/#\/c\//c:\/}"
    else
        WIN_INSTALL_PREFIX="${INSTALL_PREFIX}"
    fi
    export INSTALL_PREFIX WIN_INSTALL_PREFIX
}

latest_package_version () {
    local package="$1"
    cat "$LHELPER_DIR/recipes/index" | while read index_package version
    do
        if [[ "$index_package" == "$package" ]]; then
            echo "$version"
            return 0
        fi
    done
    return 1
}

join_by () { local IFS="$1"; shift; echo "$*"; }

get_env_directory () {
    local env_name="$1"
    echo "$LHELPER_PREFIX/var/lhenv/$env_name"
}

# Write a package line in the form "<package-name> [options] [version]" into
# a register file, a line for each package. If the package is already
# in the "register" file the line is updated otherwise it is added at the
# end.
package_file_add () {
    local package_filename="$1" package_name="$2" package_line="${*:2}" found
    local packages_content=() line line_a
    while IFS= read -r line; do
        IFS=' ' read -ra line_a <<< "$line"
        if [ ${#line_a[@]} -eq 0 ]; then
            continue
        fi
        if [ "${line_a[0]}" == "$package_name" ]; then
            line="$package_line"
            found=yes
        fi
        packages_content+=("$line")
    done < "$package_filename"
    if [ -z ${found+x} ]; then
        packages_content+=("$package_line")
    fi
    true > "$package_filename"
    for line in "${packages_content[@]}"; do
        echo "$line" >> "$package_filename"
    done
}

package_file_remove () {
    local package_filename="$1" package_name="$2"
    local packages_content=() line
    while IFS= read -r line; do
        if [ -z "${line// }" ]; then
            continue
        fi
        if [ "${line%% *}" != "$package_name" ]; then
            packages_content+=("$line")
        fi
    done < "$package_filename"
    true > "$package_filename"
    for line in "${packages_content[@]}"; do
        echo "$line" >> "$package_filename"
    done
}

package_file_query () {
    local package_filename="$1" package_name="$2"
    local line
    while IFS= read -r line; do
        if [ -z "${line// }" ]; then
            continue
        fi
        if [[ "${line%% *}" == "$package_name" ]]; then
            echo "$line"
            return 0
        fi
    done < "$package_filename"
}

register_package () {
    local env_dir="$(get_env_directory "$LHELPER_ENV_NAME")"
    local provide_line
    package_file_add "$env_dir/bin/lhelper-packages" "$@"
    if [ -f "$LHELPER_ENV_PREFIX/logs/$package-provides" ]; then
        while IFS= read -r provide_line; do
            echo "$provide_line : $*" >> "$env_dir/bin/lhelper-packages"
        done < "$LHELPER_ENV_PREFIX/logs/$package-provides"
    fi
}

unregister_package () {
    local env_dir="$(get_env_directory "$LHELPER_ENV_NAME")"
    package_file_remove "$env_dir/bin/lhelper-packages" "$@"
    local un_provided=() un_package
    while IFS= read -r un_package; do
        if [[ "$un_package" == *" : "* ]]; then
            local pprov="${un_package% : *}"
            local pimpl="${un_package#* : }"
            if [[ ${pimpl%% *} == $1 ]]; then
                un_provided+=("${pprov%% *}")
            fi
        fi
    done < "$env_dir/bin/lhelper-packages"
    for un_package in "${un_provided[@]}"; do
        package_file_remove "$env_dir/bin/lhelper-packages" "$un_package"
    done
}

query_package () {
    local env_dir="$(get_env_directory "$LHELPER_ENV_NAME")"
    local use_link=no
    if [[ "$1" == -link ]]; then
        use_link=yes
        shift
    fi
    local query_line="$(package_file_query "$env_dir/bin/lhelper-packages" "$@")"

    # returns error is line is empty: package not found
    if [[ -z "${query_line// }" ]]; then return 1; fi

    if [[ "$query_line" == *" : "* ]]; then
        if [ $use_link == yes ]; then
            echo "${query_line#* : }"
        else
            echo "${query_line% : *}"
        fi
    else
        echo "$query_line"
    fi
}

package_is_installed () {
    local prefix="$1" package="$2"
    test -f "$prefix/packages/$package.list"
}

remove_package () {
    local prefix="$1" package="$2"
    local filename_list="$prefix/packages/$package.list"
    pushd_quiet "$prefix"
    while IFS= read -r line; do
        if [ -f "$line" ]; then
            # remove the fild installed from package
            rm "$line"
        fi
    done < "$filename_list"
    # Removing empty directories
    find "." -empty -type d -delete
    popd_quiet
    rm "$filename_list"
}

find_recipe_filename () {
    local recipe_dir="$1" package="$2" version="$3"
    local filename recipe_filename
    for filename in "${recipe_dir}/"*; do
        if [[ $filename == *"/${package}_${version}" || $filename == *"/${package}_${version}+"* ]]; then
            recipe_filename="$filename"
        fi
    done
    echo "${recipe_filename#$recipe_dir/}"
}

fix_pkgconfig_install () {
    local found_pkgconfig
    if [[ "${LHELPER_LIBDIR}" != "lib" && -d "${INSTALL_PREFIX}/lib/pkgconfig" ]]; then
        found_pkgconfig="lib/pkgconfig"
    fi
    if [[ "${LHELPER_LIBDIR}" != "lib" && -d "${INSTALL_PREFIX}/share/pkgconfig" ]]; then
        found_pkgconfig="share/pkgconfig"
    fi
    if [ -n "${found_pkgconfig}" ]; then
        local pkgconfig_libdir="$(dirname "${INSTALL_PREFIX}/${found_pkgconfig}")"
        echo "Moving pkgconfig directory from \"$(dirname ${found_pkgconfig})\" to \"${LHELPER_LIBDIR}\""
        mkdir -p "${INSTALL_PREFIX}/${LHELPER_LIBDIR}/pkgconfig"
        mv "${INSTALL_PREFIX}/${found_pkgconfig}" "${INSTALL_PREFIX}/${LHELPER_LIBDIR}"
        # Deleting empty directories in ${pkgconfig_libdir}
        find "$pkgconfig_libdir" -empty -type d -delete
    fi
}

# FIXME: add methods to detect CMake libraries and other system libraries
# that may not have a pkg-config or cmake configuration.
system_library_version () {
    if pkg-config --exists "$1" &> /dev/null; then
        pkg-config --modversion "$1"
    elif command -v "$1-config" &> /dev/null; then
        "$1-config" --version
    else
        return 1
    fi
}

# From: https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

testvercomp () {
    vercomp $1 $2
    case $? in
    0)
        if [[ $3 == *"=" ]]; then
            return 0
        fi
        ;;
    1)
        if [[ $3 == ">"* ]]; then
            return 0
        fi
        ;;
    2)
        if [[ $3 == "<"* ]]; then
            return 0
        fi
        ;;
    esac
    return 1
}

# Check that "$1" is a subset of "$2". Each argument is a space-separated
# list of options.
test_options () {
    local e
    for e in $1; do
        if [[ " $2 " != *" $e "* ]]; then
            return 1
        fi
    done
}

# Test if a package entry, second argument, for example "sdl2 -threads -opengl >=2.16.0",
# matches a package spec, first argument, for example "sdl2 -opengl 2.14.0"
#
# The package spec should give a version with a comparison sign >, >=, < or <=.
# FIXME: should support the '=' sign.
test_package_spec () {
    local line_spec="$1"
    local line_entry="$2"
    local skip_options="$3"

    IFS=' ' read -ra spec_a <<< "$line_spec"
    local spec_name="${spec_a[0]}"
    local spec_options=()
    local spec_version
    local spec_comp
    for a in "${spec_a[@]:1}"; do
        case "$a" in
        -*)
            spec_options+=("$a")
            ;;
        '>='* | '<=')
            spec_comp="${a:0:2}"
            spec_version="${a:2}"
            ;;
        '>'* | '<'*)
            spec_comp="${a:0:1}"
            spec_version="${a:1}"
            ;;
        *)
            # return 100 means abnormal error happended
            return 100
        esac
    done
    # spec_version may be unset

    IFS=' ' read -ra entry_a <<< "$line_entry"
    local entry_options=()
    local entry_version
    for a in "${entry_a[@]:1}"; do
        case "$a" in
        -*)
            entry_options+=("$a")
            ;;
        *)
            entry_version="$a"
        esac
    done
    # entry_version must be set

    if [ "$spec_name" != "${entry_a[0]}" ]; then
        return 1
    fi

    # checks that all the spec options are included in the entry options
    if [ "${skip_options}" != --skip ] && ! test_options "${spec_options[*]}" "${entry_options[*]}"; then
        # return 2 means options do not match
        return 2
    fi

    if [ ! -z ${spec_version+x} ] && [ ! testvercomp "$entry_version" "$spec_version" "$spec_comp" ]; then
        # return 3 means version do not match
        return 3
    fi
}

# fill the _missing array variable
check_dependencies () {
    local cd_package cd_dependency cd_package_found
    _missing=()
    if [ ! -f "$LHELPER_ENV_PREFIX/logs/$package-dependencies" ]; then return 0; fi
    while IFS= read -r cd_dependency; do
        if [[ "$cd_dependency" == "?"* ]]; then
            # skip packages marked with '?' as they are not required.
            continue
        fi
        cd_package=${cd_dependency/ */}
        unset cd_package_found
        if query_package $cd_package &> /dev/null; then
            cd_package_found="$(query_package $cd_package)"
        fi
        if [ ! -z ${cd_package_found+x} ]; then
            test_package_spec "$cd_dependency" "$cd_package_found"
            case $? in
            1)
                echo "Error: internal error, package name mismatch."
                exit 1
                ;;
            2)
                echo "Error: options for installed package $cd_package does not match."
                exit 1
                ;;
            3)
                echo "Error: incompatible version for installed package $cd_package."
                exit 1
                ;;
            100)
                echo "Error: Invalid package spec: \"$cd_dependency\""
                exit 1
                ;;
            *)
                echo "Package $cd_package is already installed"
            esac
        elif system_library_version "$cd_package" &> /dev/null; then
            cd_package_found="$name $(system_library_version "$cd_package")"
            if ! test_package_spec "$cd_dependency" "$cd_package_found" --skip; then
                echo "Error: incompatible version for system library $name."
                exit 1
            fi
            echo "Using system library for $cd_package."
        else
            _missing+=("$cd_dependency")
        fi
    done < "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
}

compute_package_list () {
    if [ ! -f "$LHELPER_ENV_PREFIX/logs/$package-dependencies" ]; then
        return 0
    fi
    local cp_dependency cp_name cp_version
    while IFS= read -r cp_dependency; do
        cp_name=${cp_dependency/ */}
        cp_name=${cp_name#\?}
        if query_package "$cp_name" &> /dev/null; then
            _pack_usage+=("$(query_package -link $cp_name)")
        elif system_library_version "$cp_name" &> /dev/null; then
            cp_version="$(system_library_version "$cp_name")"
            _pack_usage+=("${cp_name}[system] ${cp_version}")
        else
            _pack_usage+=("${cp_name}[not-found]")
        fi
    done < "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
}


cat_digest () {
    cat << EOF
CC="$CC"
CXX="$CXX"
CFLAGS="$CFLAGS"
CXXFLAGS="$CXXFLAGS"
LDFLAGS="$LDFLAGS"
BUILD_TYPE="$BUILD_TYPE"
MACHTYPE="$MACHTYPE"
OS_VERSION="$(find_os_release)"
EOF
    echo '# dependencies'
    echo 'cat << END_OF_DEPENDENCIES'
    local line
    for line in "${_pack_usage[@]}"; do
        echo "$line"
    done
    echo 'END_OF_DEPENDENCIES'
}


build_env_digest () {
    local _pack_usage=()
    compute_package_list
    source "$LHELPER_ENV_PREFIX/bin/lhelper-config"
    local digest_a=($(cat_digest | md5sum))
    local digest="${digest_a[0]}"
    if [ ! -f "$LHELPER_WORKING_DIR/digests/$digest" ]; then
        cat_digest > "$LHELPER_WORKING_DIR/digests/$digest"
    fi
    echo "$digest"
}


# The first argument, $run_mode, should be either "dependencies" or "run"
library_install () {
    local run_mode="$1"
    shift

    local local_recipe
    local rebuild
    while [[ "$1" == -* ]]; do
        case "$1" in
        --local)
            local_recipe=true
            ;;
        --rebuild)
            rebuild=true
            ;;
        *)
            echo "unknown install option: $1"
            exit 1
        esac
        shift
    done
    local package="$1"
    shift

    local version
    local options_a=()
    for opt in "${@:1}"; do
        case $opt in
            -pic)
                if [[ ! $MACHTYPE =~ (mingw|msys|cygwin) ]]; then
                    options_a+=("$opt")
                fi
                shift
                ;;
            -*)
                options_a+=("$opt")
                shift
                ;;
            *)
                if [ -n "$version" ]; then
                    echo "Unrecognized package argument \"$1\""
                    exit 1
                fi
                version="$1"
                shift
                ;;
        esac
    done

    options_a=($(lh-sort "${options_a[*]}"))

    local options_tag=""
    if [[ ${#options_a[@]} -ne 0 ]]; then
        options_tag=$(join_by '' "${options_a[@]}")
        options_tag="${options_tag/#-/_}"
    fi

    if [[ "$local_recipe" == "true" && -z ${version+set} ]]; then
        echo "error: version is required for local recipes"
        exit 1
    fi
    if [ -z "${version+set}" ]; then
        version="$(latest_package_version "$package")"
        if [ -z "$version" ]; then
            echo "error: cannot find package \"${package}\""
            exit 1
        fi
    fi
    local recipe_dir
    if [ -z ${local_recipe+set} ]; then
        recipe_dir="$LHELPER_DIR/recipes"
    else
        recipe_dir=.
    fi
    local recipe_filename="$(find_recipe_filename "${recipe_dir}" "$package" "$version")"
    if [ -z "${recipe_filename}" ]; then
        echo "error: no recipe found for \"${package}\" version ${version}."
        exit 1
    fi
    local recipe_version="${recipe_filename#${package}_}"

    if [ $run_mode == "run" ]; then
        if [[ ${#options_a[@]} -eq 0 ]]; then
            echo "Using recipe version ${recipe_version}"
        else
            echo "Using recipe version ${recipe_version} with options: ${options_a[*]}"
        fi

        if package_is_installed "$LHELPER_ENV_PREFIX" "$package"; then
            remove_package "$LHELPER_ENV_PREFIX" "$package"
            echo "Removed previously installed package \"$package\""
        fi
    fi

    LHELPER_TEMP_ROOT="$LHELPER_WORKING_DIR/tmp"
    set_prefix_variables "$LHELPER_TEMP_ROOT"

    source "$LHELPER_ENV_PREFIX/bin/lhelper-config"

    export package version
    export _lh_recipe_run=$run_mode
    local log_dirname="${LHELPER_ENV_PREFIX}/logs"
    if [ $run_mode == "dependencies" ]; then
        # Running recipe to get dependencies
        true > "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
        BASH_ENV="$LHELPER_DIR/build-helper.sh" bash -e "${recipe_dir}/${recipe_filename}" "${options_a[@]}" 2> "$log_dirname/deps-$package-stderr.log" 1> "$log_dirname/deps-$package-stdout.log"
        check_dependencies
        unset _lh_recipe_run
        return 0
    fi

    local digest=$(build_env_digest)

    local tar_package_filename="${package}${options_tag}_${recipe_version}_${digest}.tar.gz"
    if [[ -z ${rebuild+set} && -z ${local_recipe+set} && "$version" != "git-"* && -f "$LHELPER_WORKING_DIR/packages/${tar_package_filename}" ]]; then
        echo "Found an existing package"
    else
        prepare_temp_dir "$LHELPER_WORKING_DIR"
        echo "Building library..."
        # Execute the recipe
        BASH_ENV="$LHELPER_DIR/build-helper.sh" bash -e "${recipe_dir}/${recipe_filename}" "${options_a[@]}" 2> "$log_dirname/$package-stderr.log" 1> "$log_dirname/$package-stdout.log"
        if [ $? -ne 0 ]; then
            echo "error: building library \"$package\""
            echo "    You may inspect the log files:"
            echo
            echo "    $package-stdout.log"
            echo "    $package-stderr.log"
            echo
            echo "    located in the directory $log_dirname"
            exit 1
        fi
        fix_pkgconfig_install
        echo "done"

        library_dir_reloc "$LHELPER_TEMP_ROOT" "$WIN_INSTALL_PREFIX" "__LHELPER_PREFIX__"

        tar -C "$LHELPER_TEMP_ROOT" -czf "${tar_package_filename}" .
        mv "${tar_package_filename}" "$LHELPER_WORKING_DIR/packages"
        echo "Saved package for \"$package\""
    fi
    unset _lh_recipe_run
    set_prefix_variables "$LHELPER_ENV_PREFIX"
    local filename_list="$LHELPER_ENV_PREFIX/packages/${package}.list"
    extract_archive_reloc "${tar_package_filename}" '__LHELPER_PREFIX__' "$WIN_INSTALL_PREFIX" "$INSTALL_PREFIX" "$filename_list"
    register_package "$package" "$recipe_version" "${options_a[@]}"
    echo "Package \"$package\" successfully installed"
}

library_remove () {
    local package="$1"
    if ! package_is_installed "$LHELPER_ENV_PREFIX" "$package"; then
        echo "package \"$package\" not installed"
        exit 1
    fi
    remove_package "$LHELPER_ENV_PREFIX" "$package"
    unregister_package "$package"
    echo "Package \"$package\" successfully removed."
}

print_installed_packages () {
    local packages_file="${LHELPER_ENV_PREFIX}/bin/lhelper-packages"
    if [ -s $packages_file ]; then
        echo "Installed packages"
        echo
        while IFS= read -r line; do
            if [[ "$line" == *" : "* ]]; then
                echo "* ${line% : *} (provided by ${line#* : })"
            else
                echo "* $line"
            fi
        done < $packages_file
        echo
    else
        echo "No package installed."
    fi
}

start_subshell () {
    source "$LHELPER_WORKING_DIR/environments/$1"
    print_installed_packages
    bash --init-file "$LHELPER_DIR/lhelper-bash-init"
}

create_env () {
    bash "$LHELPER_DIR/create-env.sh" "$@"
}

# Take the environment name and its install prefix as arguments.
print_create_env_message () {
    echo "Environment \"$1\" created [$2]"
}

print_package_files () {
    local package="$1"
    cat "$LHELPER_ENV_PREFIX/packages/${package}.list"
}

print_error_no_env () {
    echo "No environement activated"
    echo "To list the packages an environement should be activated"
}

case $1 in
install)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME install <library-name> [version]"
        exit 1
    fi
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    export _missing=()
    # get dependencies
    library_install dependencies "${@:2}"
    if [[ ${#_missing[@]} -ne 0 ]]; then
        echo "Found missing packages:"; echo
        for line in "${_missing[@]}"; do
            echo "- $line"
        done
        echo; echo "The package $2 cannot be installed due to missing dependencies."
        exit 1
    fi
    echo "Installing the requested package: ${@:2}"
    library_install run "${@:2}"
    unset _missing
    ;;
activate)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME activate <env-name>"
        exit 1
    fi
    if [ ! -f "$LHELPER_WORKING_DIR/environments/$2" ]; then
        echo "The environment \"$2\" does not exist"
        exit 1
    fi
    start_subshell "$2"
    ;;
create)
    if [[ $# -lt 2 || $2 == "-"* ]]; then
        echo "Usage: $LHELPER_COMMAND_NAME create <env-name> [options] [build-type]"
        exit 1
    fi
    env_name=$2
    shift 2
    while [ ! -z ${1+x} ]; do
        case "$1" in
            -n | --create-only)
                env_activate=no
                ;;
            -e | --edit)
                env_edit=yes
                ;;
            -*)
                echo "error: unknown option $1"
                exit 1
                ;;
            *)
                if [ -z ${build_type+x} ]; then
                    build_type=$1
                else
                    echo "error: unexpected argument: \"$1\""
                    exit 1
                fi
                ;;
        esac
        shift
    done
    build_type="${build_type:-Release}"
    env_prefix="$(get_env_directory "$env_name")"
    create_env "$env_name" "$env_prefix" "$build_type" || exit 1
    if [ ! -z ${env_edit+x} ]; then
        "${EDITOR-vim}" "${env_prefix}/bin/lhelper-config"
    fi
    print_create_env_message "$env_name" "$build_type"
    if [ -z ${env_activate+x} ]; then
        echo "Activating the new environment"
        start_subshell "$env_name"
    fi
    ;;
edit)
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    "${EDITOR-vim}" "$LHELPER_ENV_PREFIX/bin/lhelper-config"
    ;;
delete)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME delete <env-name>"
        exit 1
    fi
    _env_name="$2"
    if [ -f "$LHELPER_WORKING_DIR/environments/$_env_name" ]; then
        source "$LHELPER_WORKING_DIR/environments/$_env_name"
    else
        echo "Environment $_env_name not found."
        exit 1
    fi
    # TODO: consider printing installed packages.
    # TODO: consider asking no confirmation if environment is empty.
    if [ -n "$LHELPER_ENV_PREFIX" ]; then
        echo -n "Are you sure you want to delete the environment $_env_name (y/n) ? "
        read _sure_delete
        if [[ "$_sure_delete" == "y" || "$_sure_delete" == "Y" ]]; then
            rm -fr "$LHELPER_ENV_PREFIX"
            rm -f "$LHELPER_WORKING_DIR/environments/$_env_name"
            echo "Environment $_env_name successfully deleted."
        else
            echo "Operation canceled."
        fi
        unset _sure_delete
    fi
    ;;
remove)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME remove <library-name>"
        exit 1
    fi
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    library_remove "${@:2}"
    ;;
list)
    if [ "$2" == environments ]; then
        ls -1 "$LHELPER_WORKING_DIR/environments"
    elif [ "$2" == recipes ]; then
        ls -1 "$LHELPER_DIR/recipes"
    elif [ "$2" == packages ]; then
        if [ -z ${LHELPER_ENV_NAME+x} ]; then
            print_error_no_env
            exit 1
        fi
        print_installed_packages
    elif [[ "$2" == files && -n ${3+x} ]]; then
        if [ -z ${LHELPER_ENV_NAME+x} ]; then
            print_error_no_env
            exit 1
        fi
        print_package_files "$3"
    else
        echo "Usage: $LHELPER_COMMAND_NAME list (files|environments|recipes) [package]"
        exit 1
    fi
    ;;
dir)
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    echo "${LHELPER_ENV_PREFIX}"
    ;;
update)
    if [ "$2" == recipes ]; then
        pushd_quiet "${LHELPER_DIR}/recipes"
        echo "Updating recipes"
        git fetch origin master
        git checkout -q -f master
        git reset --hard origin/master
        popd_quiet
    else
        echo "Usage: $LHELPER_COMMAND_NAME update recipes"
        exit 1
    fi
    ;;
env-source)
    if [ $# -lt 2 ]; then
        echo "usage: $LHELPER_COMMAND_NAME env-source <environment>"
        exit 1
    fi
    if [ ! -f "$LHELPER_WORKING_DIR/environments/$2" ]; then
        echo "The environment \"$2\" does not exist"
        exit 1
    fi
    echo "$LHELPER_WORKING_DIR/environments/$2"
    ;;
*)
    echo "error: unknown command $1"
    exit 1
    ;;
esac

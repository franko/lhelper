#!/usr/bin/env bash

LHELPER_COMMAND_NAME="$(basename "$0")"

if [ "$#" -lt 1 ]; then
    echo "Usage: $LHELPER_COMMAND_NAME <command> [<other options>]"
    exit 1
fi

LHELPER_BIN_DIRNAME="$(dirname "$0")"
LHELPER_PREFIX="${LHELPER_BIN_DIRNAME%/bin}"

export LHELPER_WORKING_DIR="$LHELPER_PREFIX/var/lib/lhelper"
export LHELPER_DIR="$LHELPER_PREFIX/share/lhelper"

source "$LHELPER_DIR/create-env.sh"

if [ ! -d "${LHELPER_DIR}" ]; then
    echo "error: directory \"${LHELPER_DIR}\" not found."
    echo "Lhelper may be not properly installed."
fi

pushd_quiet () { builtin pushd "$@" > /dev/null; }
popd_quiet () { builtin popd > /dev/null; }

find_os_release () {
    local uname_out
    uname_out="$(uname -s)"
    case "${uname_out}" in
        Linux*)
            if [ -f /etc/os-release ]; then
                (source /etc/os-release; echo "$ID-$VERSION_ID")
            elif [ -f /etc/redhat-release ]; then
                rh_line=$(cat /etc/redhat-release)
                rh_regex="Red Hat .* release ([^ ]+)"
                if [[ $rh_line =~ $rh_regex ]]; then
                    echo "rhel-${BASH_REMATCH[1]}"
                else
                    echo "rhel-unknown"
                fi
            elif hash lsb_release 2> /dev/null; then
                dist="$(lsb_release -i)"
                release="$(lsb_release -r)"
                echo "${dist#*:$'\t'}-${release#*:$'\t'}"
            else
                echo "linux-unknown"
            fi
            ;;
        *)
            # On MSYS2 the output is MINGW32_NT-10.0-17763
            if [[ $uname_out =~ ([^\-]+-[^\-]+) ]]; then
                echo "${BASH_REMATCH[1]}"
            else
                echo "${uname_out}"
            fi
    esac
}

prepare_temp_dir () {
    local temp_dir="$1/tmp"
    rm -fr "$temp_dir"
    mkdir "$temp_dir"
}

# Relocate prefix path references for all files in a library install's
# directory.
library_dir_reloc () {
    local archive_dir="$1"
    local old_prefix="$2"
    local new_prefix="$3"
    find "$archive_dir" '(' -name '*.la' -or -name '*.pc' -or -name '*-config' ')' -exec lh-path-replace '{}' "$old_prefix" "$new_prefix" \;
}

# Extract library archive and relocate prefix path references.
extract_archive_reloc () {
    prepare_temp_dir "$LHELPER_WORKING_DIR"
    local tar_package_filename="$1"
    local old_prefix="$2"
    local new_prefix="$3"
    local _install_prefix="$4"
    local filename_list="$5"
    local package_temp_dir="$LHELPER_WORKING_DIR/tmp"
    tar -C "$package_temp_dir" -xf "$LHELPER_WORKING_DIR/packages/${tar_package_filename}"
    library_dir_reloc "$package_temp_dir" "$old_prefix" "$new_prefix"
    # Getting list of package's files
    pushd_quiet "$package_temp_dir"
    find . > "$filename_list"
    popd_quiet
    # Copy files in the destination directory
    cp -a "$package_temp_dir/." "$_install_prefix"
}

set_prefix_variables () {
    local prefix_dir="$1"
    INSTALL_PREFIX="$prefix_dir"
    if [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "mingw"* ]]; then
        WIN_INSTALL_PREFIX="${INSTALL_PREFIX/#\/c\//c:\/}"
    else
        WIN_INSTALL_PREFIX="${INSTALL_PREFIX}"
    fi
    export INSTALL_PREFIX WIN_INSTALL_PREFIX
}

latest_package_version () {
    local package="$1"
    cat "$LHELPER_DIR/recipes/index" | while read index_package version
    do
        if [[ "$index_package" == "$package" ]]; then
            echo "$version"
            return 0
        fi
    done
    return 1
}

join_by () { local IFS="$1"; shift; echo "$*"; }

get_env_directory () {
    local env_name="$1"
    echo "$LHELPER_PREFIX/var/lhenv/$env_name"
}

# Write a package line in the form "<package-name> [options] [version]" into
# a register file, a line for each package. If the package is already
# in the "register" file the line is updated otherwise it is added at the
# end.
package_file_add () {
    local package_filename="$1" package_name="$2" package_line="${*:2}" found
    local packages_content=() line
    while IFS= read -r line; do
        if [[ "${line%% *}" == "$package_name" ]]; then
            line="$package_line"
            found=yes
        fi
        packages_content+=("$line")
    done < "$package_filename"
    if [ -z ${found+x} ]; then
        packages_content+=("$package_line")
    fi
    true > "$package_filename"
    for line in "${packages_content[@]}"; do
        echo "$line" >> "$package_filename"
    done
}

package_file_remove () {
    local package_filename="$1" package_name="$2"
    local packages_content=() line
    while IFS= read -r line; do
        if [[ "${line%% *}" != "$package_name" ]]; then
            packages_content+=("$line")
        fi
    done < "$package_filename"
    true > "$package_filename"
    for line in "${packages_content[@]}"; do
        echo "$line" >> "$package_filename"
    done
}

package_file_query () {
    local package_filename="$1" package_name="$2"
    local line
    while IFS= read -r line; do
        if [[ "${line%% *}" == "$package_name" ]]; then
            echo "$line"
            return 0
        fi
    done < "$package_filename"
}

register_package () {
    local env_dir="$LHELPER_ENV_PREFIX"
    local provide_line
    package_file_add "$env_dir/bin/lhelper-packages" "$@"
    if [ -f "$LHELPER_ENV_PREFIX/logs/$package-provides" ]; then
        while IFS= read -r provide_line; do
            echo "$provide_line : $*" >> "$env_dir/bin/lhelper-packages"
        done < "$env_dir/logs/$package-provides"
    fi
}

unregister_package () {
    local env_dir="$LHELPER_ENV_PREFIX"
    package_file_remove "$env_dir/bin/lhelper-packages" "$@"
    local un_provided=() un_package
    while IFS= read -r un_package; do
        if [[ "$un_package" == *" : "* ]]; then
            local pprov="${un_package% : *}"
            local pimpl="${un_package#* : }"
            if [[ ${pimpl%% *} == $1 ]]; then
                un_provided+=("${pprov%% *}")
            fi
        fi
    done < "$env_dir/bin/lhelper-packages"
    for un_package in "${un_provided[@]}"; do
        package_file_remove "$env_dir/bin/lhelper-packages" "$un_package"
    done
}

query_package () {
    local env_dir="$LHELPER_ENV_PREFIX"
    local use_link=no
    if [[ "$1" == -link ]]; then
        use_link=yes
        shift
    fi
    local query_line="$(package_file_query "$env_dir/bin/lhelper-packages" "$@")"

    # returns error is line is empty: package not found
    if [[ -z "${query_line// }" ]]; then return 1; fi

    if [[ "$query_line" == *" : "* ]]; then
        if [ $use_link == yes ]; then
            echo "${query_line#* : }"
        else
            echo "${query_line% : *}"
        fi
    else
        echo "$query_line"
    fi
}

package_is_installed () {
    local prefix="$1" package="$2"
    test -f "$prefix/packages/$package.list"
}

remove_package () {
    local prefix="$1" package="$2"
    local filename_list="$prefix/packages/$package.list"
    pushd_quiet "$prefix"
    while IFS= read -r line; do
        if [ -f "$line" ]; then
            # remove the fild installed from package
            rm "$line"
        fi
    done < "$filename_list"
    # Removing empty directories
    find "." -empty -type d -delete
    popd_quiet
    rm "$filename_list"
}

find_recipe_filename () {
    local recipe_dir="$1" package="$2" version="$3"
    local filename recipe_filename
    for filename in "${recipe_dir}/"*; do
        if [[ $filename == *"/${package}_${version}" || $filename == *"/${package}_${version}+"* ]]; then
            recipe_filename="$filename"
        fi
    done
    echo "${recipe_filename#$recipe_dir/}"
}

fix_pkgconfig_install () {
    local found_pkgconfig
    if [[ "${LHELPER_LIBDIR}" != "lib" && -d "${INSTALL_PREFIX}/lib/pkgconfig" ]]; then
        found_pkgconfig="lib/pkgconfig"
    fi
    if [[ "${LHELPER_LIBDIR}" != "lib" && -d "${INSTALL_PREFIX}/share/pkgconfig" ]]; then
        found_pkgconfig="share/pkgconfig"
    fi
    if [ -n "${found_pkgconfig}" ]; then
        local pkgconfig_libdir="$(dirname "${INSTALL_PREFIX}/${found_pkgconfig}")"
        echo "Moving pkgconfig directory from \"$(dirname ${found_pkgconfig})\" to \"${LHELPER_LIBDIR}\""
        mkdir -p "${INSTALL_PREFIX}/${LHELPER_LIBDIR}/pkgconfig"
        mv "${INSTALL_PREFIX}/${found_pkgconfig}" "${INSTALL_PREFIX}/${LHELPER_LIBDIR}"
        # Deleting empty directories in ${pkgconfig_libdir}
        find "$pkgconfig_libdir" -empty -type d -delete
    fi
}

# FIXME: add methods to detect CMake libraries and other system libraries
# that may not have a pkg-config or cmake configuration.
system_library_version () {
    if pkg-config --exists "$1" &> /dev/null; then
        pkg-config --modversion "$1"
    elif command -v "$1-config" &> /dev/null; then
        "$1-config" --version
    else
        return 1
    fi
}

# From: https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

testvercomp () {
    vercomp $1 $2
    case $? in
    0)
        if [[ $3 == *"=" ]]; then
            return 0
        fi
        ;;
    1)
        if [[ $3 == ">"* ]]; then
            return 0
        fi
        ;;
    2)
        if [[ $3 == "<"* ]]; then
            return 0
        fi
        ;;
    esac
    return 1
}

# Check that "$1" is a subset of "$2". Each argument is a space-separated
# list of options.
test_options () {
    local e
    for e in $1; do
        if [[ " $2 " != *" $e "* ]]; then
            return 1
        fi
    done
}

# Test if a package entry, second argument, for example "sdl2 -threads -opengl >=2.16.0",
# matches a package spec, first argument, for example "sdl2 -opengl 2.14.0"
#
# The package spec should give a version with a comparison sign >, >=, < or <=.
test_package_spec () {
    local line_spec="$1"
    local line_entry="$2"
    local skip_options="$3"

    IFS=' ' read -ra spec_a <<< "$line_spec"
    local spec_name="${spec_a[0]}"
    local spec_options=()
    local spec_version
    local spec_comp
    for a in "${spec_a[@]:1}"; do
        case "$a" in
        -*)
            spec_options+=("$a")
            ;;
        '>='* | '<='*)
            spec_comp="${a:0:2}"
            spec_version="${a:2}"
            ;;
        '>'* | '<'* | '='*)
            spec_comp="${a:0:1}"
            spec_version="${a:1}"
            ;;
        *)
            # return 100 means abnormal error happended
            return 100
        esac
    done
    # spec_version may be unset

    IFS=' ' read -ra entry_a <<< "$line_entry"
    local entry_options=()
    local entry_version
    for a in "${entry_a[@]:1}"; do
        case "$a" in
        -*)
            entry_options+=("$a")
            ;;
        *)
            entry_version="$a"
        esac
    done
    # entry_version must be set

    if [ "$spec_name" != "${entry_a[0]}" ]; then
        return 1
    fi

    # checks that all the spec options are included in the entry options
    if [ "${skip_options}" != --skip ] && ! test_options "${spec_options[*]}" "${entry_options[*]}"; then
        # return 2 means options do not match
        return 2
    fi

    if [ ! -z ${spec_version+x} ] && [ ! testvercomp "$entry_version" "$spec_version" "$spec_comp" ]; then
        # return 3 means version do not match
        return 3
    fi
}

# fill the _missing array variable
check_dependencies () {
    local cd_package cd_dependency cd_package_found
    _missing=()
    if [ ! -f "$LHELPER_ENV_PREFIX/logs/$package-dependencies" ]; then return 0; fi
    while IFS= read -r cd_dependency; do
        if [[ "$cd_dependency" == "?"* ]]; then
            # skip packages marked with '?' as they are not required.
            continue
        fi
        cd_package=${cd_dependency/ */}
        unset cd_package_found
        if query_package $cd_package &> /dev/null; then
            cd_package_found="$(query_package $cd_package)"
        fi
        if [ ! -z ${cd_package_found+x} ]; then
            test_package_spec "$cd_dependency" "$cd_package_found"
            case $? in
            1)
                echo "Error: internal error, package name mismatch."
                exit 1
                ;;
            2)
                echo "Error: options for installed package $cd_package does not match."
                exit 1
                ;;
            3)
                echo "Error: incompatible version for installed package $cd_package."
                exit 1
                ;;
            100)
                echo "Error: Invalid package spec: \"$cd_dependency\""
                exit 1
                ;;
            *)
                $message "Package $cd_package is already installed"
            esac
        elif system_library_version "$cd_package" &> /dev/null; then
            cd_package_found="$name $(system_library_version "$cd_package")"
            if ! test_package_spec "$cd_dependency" "$cd_package_found" --skip; then
                echo "Error: incompatible version for system library $name."
                exit 1
            fi
            $message "Using system library for $cd_package."
        else
            _missing+=("$cd_dependency")
        fi
    done < "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
}

contains_element () {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

compute_package_list () {
    if [ ! -f "$LHELPER_ENV_PREFIX/logs/$package-dependencies" ]; then
        return 0
    fi
    local cp_dependency cp_name cp_version cp_entry
    while IFS= read -r cp_dependency; do
        cp_name=${cp_dependency/ */}
        cp_name=${cp_name#\?}
        if query_package "$cp_name" &> /dev/null; then
            cp_entry="$(query_package -link $cp_name)"
            if ! contains_element "$cp_entry" "${_pack_usage[@]}"; then
                _pack_usage+=("$cp_entry")
            fi
        elif system_library_version "$cp_name" &> /dev/null; then
            cp_version="$(system_library_version "$cp_name")"
            _pack_usage+=("${cp_name}[system] ${cp_version}")
        else
            _pack_usage+=("${cp_name}[not-found]")
        fi
    done < "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
}

get_compiler_version () {
    local cc="$1"
    local ver="$($cc --version | head -n 1)"
    if [[ "$ver" =~ gcc.*\((.*)\)\ +([0-9]+)\.[0-9]+.* ]]; then
        echo "gcc (${BASH_REMATCH[1]}) ${BASH_REMATCH[2]}"
    elif [[ "$ver" =~ g\+\+.*\((.*)\)\ +([0-9]+)\.[0-9]+.* ]]; then
        echo "g++ (${BASH_REMATCH[1]}) ${BASH_REMATCH[2]}"
    elif [[ "$ver" =~ clang\ +version\ +([0-9]+)\.[0-9]+.* ]]; then
        echo "clang ${BASH_REMATCH[1]}"
    else
        echo "$ver"
    fi
}

cat_digest () {
    cat << EOF
CC="$CC_BARE"
CXX="$CXX_BARE"
CFLAGS="$CFLAGS"
CXXFLAGS="$CXXFLAGS"
LDFLAGS="$LDFLAGS"
BUILD_TYPE="$BUILD_TYPE"
MACHTYPE="$MACHTYPE"
CPU_TYPE="$CPU_TYPE"
CPU_TARGET="$CPU_TARGET"
CC_VERSION="$(get_compiler_version "$CC_BARE")"
CXX_VERSION="$(get_compiler_version "$CXX_BARE")"
OS_VERSION="$(find_os_release)"
EOF
    echo '# dependencies'
    echo 'cat << END_OF_DEPENDENCIES'
    cat "$LHELPER_ENV_PREFIX/logs/$package-usage"
    echo 'END_OF_DEPENDENCIES'
}


build_env_digest () {
    local _pack_usage=()
    compute_package_list
    source "$LHELPER_ENV_PREFIX/bin/lhelper-config"

    true > "$LHELPER_ENV_PREFIX/logs/$package-usage"
    local line
    for line in "${_pack_usage[@]}"; do
        echo "$line" >> "$LHELPER_ENV_PREFIX/logs/$package-usage"
    done
    unset _pack_usage

    local digest_a=($(cat_digest | md5sum))
    local digest="${digest_a[0]}"

    if [ ! -f "$LHELPER_WORKING_DIR/digests/$digest" ]; then
        cat_digest > "$LHELPER_WORKING_DIR/digests/$digest"
    fi
    echo "$digest"
}


# The first argument, $run_mode, should be either "dependencies", "run" or "log"
library_install () {
    local run_mode="$1"
    shift

    local local_recipe
    local rebuild
    while [[ "$1" == -* ]]; do
        case "$1" in
        --local)
            local_recipe=true
            ;;
        --rebuild)
            rebuild=true
            ;;
        *)
            echo "unknown install option: $1"
            exit 1
        esac
        shift
    done
    local package="$1"
    shift

    local version
    local options_a=()
    for opt in "${@:1}"; do
        case $opt in
            -pic)
                if [[ ! $MACHTYPE =~ (mingw|msys|cygwin) ]]; then
                    options_a+=("$opt")
                fi
                shift
                ;;
            -*)
                options_a+=("$opt")
                shift
                ;;
            *)
                if [ -n "$version" ]; then
                    echo "Unrecognized package argument \"$1\""
                    exit 1
                fi
                version="$1"
                shift
                ;;
        esac
    done

    options_a=($(lh-sort "${options_a[*]}"))

    local options_tag=""
    if [[ ${#options_a[@]} -ne 0 ]]; then
        options_tag=$(join_by '' "${options_a[@]}")
        options_tag="${options_tag/#-/_}"
    fi

    if [[ "$local_recipe" == "true" && -z ${version+set} ]]; then
        echo "error: version is required for local recipes"
        exit 1
    fi
    if [ -z "${version+set}" ]; then
        version="$(latest_package_version "$package")"
        if [ -z "$version" ]; then
            echo "error: cannot find package \"${package}\""
            exit 1
        fi
    fi
    local recipe_dir
    if [ -z ${local_recipe+set} ]; then
        recipe_dir="$LHELPER_DIR/recipes"
    else
        recipe_dir=.
    fi
    local recipe_filename="$(find_recipe_filename "${recipe_dir}" "$package" "$version")"
    if [ -z "${recipe_filename}" ]; then
        echo "error: no recipe found for \"${package}\" version ${version}."
        exit 1
    fi
    local recipe_version="${recipe_filename#${package}_}"

    if [ $run_mode == run ]; then
        if [[ ${#options_a[@]} -eq 0 ]]; then
            $message "Using recipe version ${recipe_version}"
        else
            $message "Using recipe version ${recipe_version} with options: ${options_a[*]}"
        fi

        if package_is_installed "$LHELPER_ENV_PREFIX" "$package"; then
            remove_package "$LHELPER_ENV_PREFIX" "$package"
            $message "Removed previously installed package \"$package\""
        fi
    fi

    LHELPER_TEMP_ROOT="$LHELPER_WORKING_DIR/tmp"
    set_prefix_variables "$LHELPER_TEMP_ROOT"

    source "$LHELPER_ENV_PREFIX/bin/lhelper-config"

    export package version
    export _lh_recipe_run=$run_mode
    local log_dirname="${LHELPER_ENV_PREFIX}/logs"
    local digest
    if [ $run_mode == dependencies ]; then
        # Running recipe to get dependencies
        true > "$LHELPER_ENV_PREFIX/logs/$package-dependencies"
        BASH_ENV="$LHELPER_DIR/build-helper.sh" bash -e "${recipe_dir}/${recipe_filename}" "${options_a[@]}" 2> "$log_dirname/deps-$package-stderr.log" 1> "$log_dirname/deps-$package-stdout.log"
        check_dependencies
        unset _lh_recipe_run
        return 0
    elif [ $run_mode == log ]; then
        digest=$(build_env_digest)
        register_package "$package" "$recipe_version" "${options_a[@]}" "$digest"
        return 0
    else
        digest=$(build_env_digest)
    fi

    local pu_line
    local pu_list=()
    while IFS= read -r pu_line; do
        pu_list+=("$pu_line")
    done < "$LHELPER_ENV_PREFIX/logs/$package-usage"
    rm "$LHELPER_ENV_PREFIX/logs/$package-usage"
    if [[ ${#pu_list[@]} -gt 0 ]]; then
        $message "The package dependencies are:"; echo
        for pu_line in "${pu_list[@]}"; do
            $message "* $pu_line"
        done
        $message
    else
        $message "The package has no dependencies."
    fi

    local tar_package_filename="${package}${options_tag}_${recipe_version}_${digest}.tar.gz"
    if [[ -z ${rebuild+set} && -z ${local_recipe+set} && "$version" != "git-"* && -f "$LHELPER_WORKING_DIR/packages/${tar_package_filename}" ]]; then
        $message "Found an existing package"
    else
        prepare_temp_dir "$LHELPER_WORKING_DIR"
        $message "Building library..."
        # Execute the recipe
        BASH_ENV="$LHELPER_DIR/build-helper.sh" bash -e "${recipe_dir}/${recipe_filename}" "${options_a[@]}" 2> "$log_dirname/$package-stderr.log" 1> "$log_dirname/$package-stdout.log"
        if [ $? -ne 0 ]; then
            echo "error: building library \"$package\""
            echo "    You may inspect the log files:"
            echo
            echo "    $package-stdout.log"
            echo "    $package-stderr.log"
            echo
            echo "    located in the directory $log_dirname"
            exit 1
        fi
        fix_pkgconfig_install
        $message "done"

        library_dir_reloc "$LHELPER_TEMP_ROOT" "$WIN_INSTALL_PREFIX" "__LHELPER_PREFIX__"

        tar -C "$LHELPER_TEMP_ROOT" -czf "${tar_package_filename}" .
        mv "${tar_package_filename}" "$LHELPER_WORKING_DIR/packages"
        echo "Saved package for \"$package\""
    fi
    unset _lh_recipe_run
    set_prefix_variables "$LHELPER_ENV_PREFIX"
    local filename_list="$LHELPER_ENV_PREFIX/packages/${package}.list"
    extract_archive_reloc "${tar_package_filename}" '__LHELPER_PREFIX__' "$WIN_INSTALL_PREFIX" "$INSTALL_PREFIX" "$filename_list"
    register_package "$package" "$recipe_version" "${options_a[@]}" "$digest"
    $message "Package \"$package\" successfully installed"
}

library_remove () {
    local package="$1"
    if ! package_is_installed "$LHELPER_ENV_PREFIX" "$package"; then
        echo "package \"$package\" not installed"
        exit 1
    fi
    remove_package "$LHELPER_ENV_PREFIX" "$package"
    unregister_package "$package"
    echo "Package \"$package\" successfully removed."
}

print_installed_packages () {
    local packages_file="${LHELPER_ENV_PREFIX}/bin/lhelper-packages"
    if [ -s $packages_file ]; then
        echo "Installed packages"
        echo
        while IFS= read -r line; do
            if [[ "$line" == *" : "* ]]; then
                echo "* ${line% : *} (provided by ${line#* : })"
            else
                echo "* $line"
            fi
        done < $packages_file
        echo
    else
        echo "No package installed."
    fi
}

start_subshell () {
    print_installed_packages
    bash --init-file "$LHELPER_DIR/lhelper-bash-init"
}

# Take the environment name and its install prefix as arguments.
print_create_env_message () {
    echo "Environment \"$1\" created [$2]"
}

print_package_files () {
    local package="$1"
    cat "$LHELPER_ENV_PREFIX/packages/${package}.list"
}

print_error_no_env () {
    echo "No environment activated"
    echo "To list the packages an environment should be activated"
}

library_check_and_install () {
    local mode=$1
    shift

    local message
    if [ -z ${package_quiet} ]; then
        message=echo
    else
        message=true
    fi

    local _missing=()
    # get dependencies
    library_install dependencies "$@"
    if [[ ${#_missing[@]} -ne 0 ]]; then
        $message "Found missing packages:"; echo
        for line in "${_missing[@]}"; do
            $message "- $line"
        done
        $message; $message "The package $1 cannot be installed due to missing dependencies."
        exit 1
    fi
    if [ $mode == run ]; then
        $message "Installing the requested package: $@"
    fi
    library_install $mode "$@"
}

# print all the arguments but the second and the last one. Ensure no space is added
# if there are no remaining elements after the first.
# Needed because a package line is in the form: <package> <version> [options] <digest>
# and we don't want the version neither the digest.
package_of_line () {
    join_by " " "$1" "${@:3:${#@}-3}"
}

update_installed_packages () {
    local package_line package_requested package_installed match_found packages_keep=()
    while IFS= read -r package_line; do
        if [[ $package_line == *" : "* ]]; then
            packages_keep+=("$package_line")
            continue
        fi
        package_installed="$(package_of_line $package_line)"
        match_found=no
        for package_requested in "${packages[@]}"; do
            if [[ $package_requested == $package_installed ]]; then
                match_found=yes
                break
            fi
        done
        if [ $match_found == no ]; then
            # Note the second argument is unquoted, we want to keep only the package name
            # while "package_installed" may contain options.
            remove_package "$LHELPER_ENV_PREFIX" $package_installed
        else
            packages_keep+=("$package_line")
        fi
    done < "$LHELPER_ENV_PREFIX/bin/lhelper-packages"

    for package_line in "${packages_keep[@]}"; do echo "$package_line"; done > "$LHELPER_ENV_PREFIX/bin/lhelper-packages"

    for package_requested in "${packages[@]}"; do
        match_found=no
        for package_line in "${packages_keep[@]}"; do
            if [[ $package_line == *" : "* ]]; then continue; fi
            package_installed="$(package_of_line $package_line)"
            if [[ $package_installed == $package_requested ]]; then
                match_found=yes
                break
            fi
        done
        if [ $match_found == no ]; then
            # Note the second argument below needs to go unquoted.
            library_check_and_install run $package_requested
        fi
    done
}

case $1 in
install)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME install <library-name> [version]"
        exit 1
    fi
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    library_check_and_install run "${@:2}"
    ;;
env-source | activate)
    if [[ $# -lt 2 || $2 == "-"* ]]; then
        echo "Usage: $LHELPER_COMMAND_NAME activate <spec-filename> [options]"
        exit 1
    fi
    if [ $1 == env-source ]; then
        source_print=yes
        package_quiet=yes
    fi
    env_filename="$2"
    shift 2
    while [ ! -z ${1+x} ]; do
        case "$1" in
        -e | --edit)
            edit_file=yes
            ;;
        -n | --create-only)
            create_only=yes
            ;;
        -*)
            echo "error: unknown option $1"
            exit 1
            ;;
        *)
            echo "error: unexpected argument: \"$1\""
            exit 1
            ;;
        esac
        shift
    done

    if [[ ! -f "$env_filename" && ! $env_filename =~ \.lhelper$ ]]; then
        env_filename="$env_filename.lhelper"
    fi
    if [[ ! -z ${edit_file+x} && ! -f "$env_filename" ]]; then
        cat << EOF > "$env_filename"
# This is bash script sourced to get some environment variables to configure the
# build toolchain.

# Set the variables CC and CXX to point to the C and C++ compilers to use.
# They may contains options by separating them by spaces and quoting the command.
CC=gcc
CXX=g++

# Optional C/C++ and linker flags.
# Do not include optimization or debug flags as they are automatically added based
# on the variable BUILD_TYPE.
# CPU specific flags are automatically added based on CPU_TYPE and CPU_TARGET.
# CFLAGS=
# CXXFLAGS=
# LDFLAGS=

# CPU architecture type and specific CPU to target. These variables are
# mandatory. In case of doubt for CPU_TARGET you may choose a generic target like
# x86-64 (generic). You can choose an Intel, AMD or ARM CPU microarchitecture like
# nehalem, haswell or athlon for example.
CPU_TYPE=x86-64
CPU_TARGET=nehalem

# Debug can be used to build the libraries including debug information.
# It omitted will defaut to a release build.
BUILD_TYPE=Release

# List of libraries to be installed. Can contain options by quoting the a string with
# the libray name and its option followed by spaces.
packages=(
#   "freetype2"
#   "sdl2 -opengl"
)
EOF
    fi
    if [[ ! -z ${edit_file+x} ]]; then
        "${EDITOR-vim}" "$env_filename"
    fi
    if [ ! -f "$env_filename" ]; then
        echo "error: the file $env_filename does not exist or is not a file"
        exit 1
    fi

    source "$env_filename"
    if [ -z ${BUILD_TYPE+x} ]; then
        BUILD_TYPE=Release
    elif [[ $BUILD_TYPE != "Release" && $BUILD_TYPE != "Debug" ]]; then
        echo "Build type should be either Release or Debug, abort."
        exit 1
    fi
    if [[ -z ${CPU_TYPE+x} || -z ${CPU_TARGET+x} ]]; then
        echo "error: please provide the CPU_TYPE and CPU_TARGET environment variables."
        echo "The CPU type should be something like \"prescott\" or \"x86-64\"."
        echo "The CPU target should be something like \"x86\", \"x86-64\" or \"arm64\"."
        exit 1
    fi

    env_realpath="$(realpath "$env_filename")"
    env_basename="$(basename "$env_filename")"
    env_workdir="$(dirname "$env_realpath")/.lhelper"
    env_source="$env_workdir/.env_source"

    # Temporary environment creation
    rm -fr "$env_workdir/tmp" "$env_workdir/.env_source"
    mkdir -p "$env_workdir/tmp" "$env_workdir/env"
    create_env "${env_basename%.lhelper}" "$env_workdir/tmp" "$env_source"
    # run through the packages to log them in the temporary environment
    (
        source "$env_source"
        for package_name in "${packages[@]}"; do
            # Important: variable package_name can contain spaces and it must be used
            # below *without* quotes.
            library_check_and_install log $package_name
        done
    )

    # Looking for a matching environment from the existing ones
    pushd_quiet "$env_workdir/env"
    new_env_no=1
    shopt -s nullglob
    for env_no in *; do
        if cmp -s "$env_workdir/tmp/bin/lhelper-config" "$env_no/bin/lhelper-config" &&
            cmp -s "$env_workdir/tmp/bin/lhelper-packages" "$env_no/bin/lhelper-packages"; then
            matching_env="$env_no"
            break
        fi
        if [[ $env_no =~ ^-?[0-9]+$ && $env_no -ge "$new_env_no" ]]; then
            new_env_no=$(($env_no + 1))
        fi
    done
    popd_quiet

    # create the new environment or activate the one found
    rm -fr "$env_workdir/tmp" "$env_source"
    if [ -z ${matching_env+x} ]; then
        # create a new environment
        env_prefix="$env_workdir/env/$new_env_no"
        create_env "${env_basename%.lhelper}" "$env_prefix" "$env_prefix/bin/activate"
        env_source="$env_prefix/bin/activate"
        # install packages, activate the environment before
        source "$env_source"
        for package_name in "${packages[@]}"; do
            # Important: variable package_name can contain spaces and it must be used
            # below *without* quotes.
            library_check_and_install run $package_name
        done
    else
        # points env_source to the activate script of the matching environment
        env_source="$env_workdir/env/$matching_env/bin/activate"
        source "$env_source"
    fi
    if [ ! -z ${source_print} ]; then
        echo "$env_source"
    elif [ -z ${create_only+x} ]; then
        echo "Starting a new shell with the new environment"
        while true; do
            start_subshell
            # We consider an exit status 11 as a requst to restart the environment
            # after a change in the build file.
            if [ $? != 11 ]; then break; fi
            source "$env_filename"
            update_installed_packages
        done
    fi
    ;;
edit)
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    "${EDITOR-vim}" "$LHELPER_ENV_PREFIX/../../../$LHELPER_ENV_NAME.lhelper"
    # We send a SIGUSR1 to the parent process, the activated bash shell.
    # The variable PPID is a builtin bash variable for the PID of the parent process.
    kill -s SIGUSR1 $PPID
    ;;
cleanup)
    if [ -d ".lhelper/env" ]; then
        echo "Cleaning up the environments cached in .lhelper/env"
        rm -fr ".lhelper/env"
    else
        echo "No environments found in .lhelper directory, no files deleted"
    fi
    ;;
remove)
    if [ $# -lt 2 ]; then
        echo "Usage: $LHELPER_COMMAND_NAME remove <library-name>"
        exit 1
    fi
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    library_remove "${@:2}"
    ;;
list)
    if [ "$2" == recipes ]; then
        ls -1 "$LHELPER_DIR/recipes"
    elif [ "$2" == packages ]; then
        if [ -z ${LHELPER_ENV_NAME+x} ]; then
            print_error_no_env
            exit 1
        fi
        print_installed_packages
    elif [[ "$2" == files && -n ${3+x} ]]; then
        if [ -z ${LHELPER_ENV_NAME+x} ]; then
            print_error_no_env
            exit 1
        fi
        print_package_files "$3"
    else
        echo "Usage: $LHELPER_COMMAND_NAME list (files|environments|recipes) [package]"
        exit 1
    fi
    ;;
dir)
    if [ -z ${LHELPER_ENV_NAME+x} ]; then
        print_error_no_env
        exit 1
    fi
    echo "${LHELPER_ENV_PREFIX}"
    ;;
update)
    if [ "$2" == recipes ]; then
        pushd_quiet "${LHELPER_DIR}/recipes"
        echo "Updating recipes"
        _branch_name="$(git rev-parse --abbrev-ref HEAD)"
        git fetch origin "$_branch_name"
        git checkout -q -f "$_branch_name"
        git reset --hard "origin/$_branch_name"
        popd_quiet
    else
        echo "Usage: $LHELPER_COMMAND_NAME update recipes"
        exit 1
    fi
    ;;
env-source)
    if [ $# -lt 2 ]; then
        echo "usage: $LHELPER_COMMAND_NAME env-source <environment>"
        exit 1
    fi
    if [ ! -f "$LHELPER_WORKING_DIR/environments/$2" ]; then
        echo "The environment \"$2\" does not exist"
        exit 1
    fi
    echo "$LHELPER_WORKING_DIR/environments/$2"
    ;;
*)
    echo "error: unknown command $1"
    exit 1
    ;;
esac
